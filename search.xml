<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Longest Palindrome(409)]]></title>
    <url>%2F2020%2F06%2F14%2FLongest-Palindrome-409%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617/*Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.This is case sensitive, for example &quot;Aa&quot; is not considered a palindrome here.Note:Assume the length of given string will not exceed 1,010.Example:Input:&quot;abccccdd&quot;Output:7Explanation:One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.*/ 1234567891011121314func longestPalindrome(s string) int &#123; exist := make(map[byte]struct&#123;&#125;) for i := range s&#123; if _, ok := exist[s[i]]; ok&#123; delete(exist, s[i]) &#125; else&#123; exist[s[i]] = struct&#123;&#125;&#123;&#125; &#125; &#125; if len(exist) == 0&#123; return len(s) &#125; return len(s) - len(exist) + 1&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Happy Number(202)]]></title>
    <url>%2F2020%2F06%2F12%2FHappy-Number-202%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819/*Write an algorithm to determine if a number n is &quot;happy&quot;.A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.Return True if n is a happy number, and False if not.Example: Input: 19Output: trueExplanation: 12 + 92 = 8282 + 22 = 6862 + 82 = 10012 + 02 + 02 = 1*/ 1234567891011121314func isHappy(n int) bool &#123; visited := make(map[int]struct&#123;&#125;) for&#123; if n == 1&#123; return true&#125; if _, ok := visited[n]; ok&#123; return false&#125; visited[n] = struct&#123;&#125;&#123;&#125; tmp := 0 for i := n; i &gt; 0; i = i / 10&#123; j := i % 10 tmp += j * j &#125; n = tmp &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum Index Sum of Two Lists(599)]]></title>
    <url>%2F2020%2F06%2F07%2FMinimum-Index-Sum-of-Two-Lists-599%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122/*Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.Example 1:Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;Piatti&quot;, &quot;The Grill at Torrey Pines&quot;, &quot;Hungry Hunter Steakhouse&quot;, &quot;Shogun&quot;]Output: [&quot;Shogun&quot;]Explanation: The only restaurant they both like is &quot;Shogun&quot;.Example 2:Input:[&quot;Shogun&quot;, &quot;Tapioca Express&quot;, &quot;Burger King&quot;, &quot;KFC&quot;][&quot;KFC&quot;, &quot;Shogun&quot;, &quot;Burger King&quot;]Output: [&quot;Shogun&quot;]Explanation: The restaurant they both like and have the least index sum is &quot;Shogun&quot; with index sum 1 (0+1).*/ 123456789101112131415161718192021func findRestaurant(list1 []string, list2 []string) []string &#123; andyMap := make(map[string]int) for k, v := range list1&#123; andyMap[v] = k &#125; minIdx := len(list1) + len(list2) ret := make([]string, 0) for k, v := range list2&#123; if value, ok := andyMap[v]; ok&#123; currIdx := k + value if currIdx &lt; minIdx&#123; ret = []string&#123;v&#125; minIdx = currIdx &#125; else if currIdx == minIdx&#123; ret = append(ret, v) &#125; &#125; &#125; return ret&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Unique Character in a String(387)]]></title>
    <url>%2F2020%2F06%2F06%2FFirst-Unique-Character-in-a-String-387%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324/*Given a string, find the first non-repeating character in it and return it&apos;s index. If it doesn&apos;t exist, return -1.Examples:s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2.*/func firstUniqChar(s string) int &#123; tmp := make([]int, 26) for _, v := range s &#123; tmp[v-&apos;a&apos;]++ &#125; for i, v := range s &#123; if tmp[v-&apos;a&apos;] == 1 &#123; return i &#125; &#125; return -1&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find the Difference(389)]]></title>
    <url>%2F2020%2F06%2F03%2FFind-the-Difference-389%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627/*Given two strings s and t which consist of only lowercase letters.String t is generated by random shuffling string s and then add one more letter at a random position.Find the letter that was added in t.Example:Input:s = &quot;abcd&quot;t = &quot;abcde&quot;Output:eExplanation:&apos;e&apos; is the letter that was added.*/func findTheDifference(s string, t string) byte &#123; rs := []byte(s) rt := []byte(t) rst := rt[len(s)] for i, _ := range rs &#123; rst -= rs[i] rst += rt[i] &#125; return rst&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Design HashSet(705)]]></title>
    <url>%2F2020%2F06%2F02%2FDesign-HashSet-705%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718/*Design a HashSet without using any built-in hash table libraries.To be specific, your design should include these functions:add(value): Insert a value into the HashSet. contains(value) : Return whether the value exists in the HashSet or not.remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing.Example:MyHashSet hashSet = new MyHashSet();hashSet.add(1); hashSet.add(2); hashSet.contains(1); // returns truehashSet.contains(3); // returns false (not found)hashSet.add(2); hashSet.contains(2); // returns truehashSet.remove(2); hashSet.contains(2); // returns false (already removed)*/ 12345678910111213141516171819202122232425262728type MyHashSet struct&#123; capacity int data []bool&#125;func Constructor() MyHashSet&#123; capacity := 1000001 return MyHashSet&#123; capacity : capacity, data : make([]bool, capacity), &#125;&#125;func (hs *MyHashSet) Hash(key int) int&#123; return key % hs.capacity&#125;func (hs *MyHashSet) Add(key int)&#123; hs.data[hs.Hash(key)] = true&#125;func (hs *MyHashSet) Remove(key int)&#123; hs.data[hs.Hash(key)] = false&#125;func (hs *MyHashSet) Contains(key int) bool&#123; return hs.data[hs.Hash(key)]&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Design HashMap(706)]]></title>
    <url>%2F2020%2F05%2F31%2FDesign-HashMap-706%2F</url>
    <content type="text"><![CDATA[12345678910/*Design a HashMap without using any built-in hash table libraries.To be specific, your design should include these functions:put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value.get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.remove(key) : Remove the mapping for the value key if this map contains the mapping for the key.*/ 1234567891011121314151617181920212223242526272829303132type MyHashMap struct &#123; capacity int data []int&#125;func Constructor() MyHashMap &#123; capacity := 1000001 data := make([]int, capacity) for i := range data&#123; data[i] = -1 &#125; return MyHashMap&#123; capacity : capacity, data : data, &#125;&#125;func (hm *MyHashMap) Hash(key int) int&#123; return key % hm.capacity&#125;func (hm *MyHashMap) Put(key int, value int)&#123; hm.data[hm.Hash(key)] = value&#125;func (hm *MyHashMap) Get(key int) int&#123; return hm.data[hm.Hash(key)]&#125;func (hm *MyHashMap) Remove(key int)&#123; hm.data[hm.Hash(key)] = -1&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uncommon Words from Two Sentences(884)]]></title>
    <url>%2F2020%2F05%2F30%2FUncommon-Words-from-Two-Sentences-884%2F</url>
    <content type="text"><![CDATA[1234567891011121314/*We are given two sentences A and B. (A sentence is a string of space separated words.Each word consists only of lowercase letters.)A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.Return a list of all uncommon words.You may return the list in any order.Example 1:Input: A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot;Output: [&quot;sweet&quot;,&quot;sour&quot;]Example 2:Input: A = &quot;apple apple&quot;, B = &quot;banana&quot;Output: [&quot;banana&quot;]*/ 12345678910111213141516func uncommonFromSentences(A string, B string) []string &#123; mp := make(map[string]int) for _, word := range strings.Fields(A) &#123; mp[word]++ &#125; for _, word := range strings.Fields(B) &#123; mp[word]++ &#125; var res []string for word, count := range mp &#123; if count == 1 &#123; res = append(res, word) &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Island Perimeter(463)]]></title>
    <url>%2F2020%2F05%2F29%2FIsland-Perimeter-463%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617/*You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).The island doesn&apos;t have &quot;lakes&quot; (water inside that isn&apos;t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don&apos;t exceed 100. Determine the perimeter of the island.Example:Input:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]Output: 16*/ 1234567891011121314151617func islandPerimeter(grid [][]int) int &#123; var res int for i := 0; i &lt; len(grid); i++&#123; for j := 0; j &lt; len(grid[0]); j++&#123; if grid[i][j] == 1&#123; res += 4 if i &gt; 0 &amp;&amp; grid[i - 1][j] == 1&#123; res -= 2 &#125; if j &gt; 0 &amp;&amp; grid[i][j - 1] == 1&#123; res -= 2 &#125; &#125; &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keyboard Row(500)]]></title>
    <url>%2F2020%2F05%2F26%2FKeyboard-Row-500%2F</url>
    <content type="text"><![CDATA[1234567/*Given a List of words, return the words that can be typed using letters of alphabet on only one row&apos;s of American keyboard like the image below.Example:Input: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]Output: [&quot;Alaska&quot;, &quot;Dad&quot;]*/ 12345678910111213141516171819202122232425262728293031323334func findWords(words []string) []string &#123; var ans []string for _, v := range words &#123; if findAlphabet(v) &#123; ans = append(ans, v) &#125; &#125; return ans&#125;func findAlphabet(s string) bool &#123; mp := map[rune]int&#123; &apos;q&apos;: 1, &apos;w&apos;: 1, &apos;e&apos;: 1, &apos;r&apos;: 1, &apos;t&apos;: 1, &apos;y&apos;: 1, &apos;u&apos;: 1, &apos;i&apos;: 1, &apos;o&apos;: 1, &apos;p&apos;: 1, &apos;a&apos;: 2, &apos;s&apos;: 2, &apos;d&apos;: 2, &apos;f&apos;: 2, &apos;g&apos;: 2, &apos;h&apos;: 2, &apos;j&apos;: 2, &apos;k&apos;: 2, &apos;l&apos;: 2, &apos;z&apos;: 3, &apos;x&apos;: 3, &apos;c&apos;: 3, &apos;v&apos;: 3, &apos;b&apos;: 3, &apos;n&apos;: 3, &apos;m&apos;: 3, &#125; row := 0 for k, v := range s &#123; if v &gt;= 65 &amp;&amp; v &lt;= 90 &#123; v = v + 32 &#125; if k == 0 &#123; row = mp[v] &#125; if v, ok := mp[v]; ok &amp;&amp; row != v &#123; return false &#125; &#125; return true&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unique Number of Occurrences(1207)]]></title>
    <url>%2F2020%2F05%2F25%2FUnique-Number-of-Occurrences-1207%2F</url>
    <content type="text"><![CDATA[/* Given an array of integers arr, write a function that returns true if and only if the number of occurrences of each value in the array is unique. Example 1: Input: arr = [1,2,2,1,1,3] Output: true Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. Example 2: Input: arr = [1,2] Output: false Example 3: Input: arr = [-3,0,1,-3,1,1,1,-3,10,0] Output: true */ func uniqueOccurrences(arr []int) bool { mp := make(map[int]int) for i := 0; i &lt; len(arr); i++ { mp[arr[i]] += 1 } tmp := make(map[int]int) for _, v := range mp { if _, exists := tmp[v]; exists { return false } tmp[v] = 1 } return true }]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N-Repeated Element in Size 2N Array(961)]]></title>
    <url>%2F2020%2F05%2F24%2FN-Repeated-Element-in-Size-2N-Array-961%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526/*In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.Return the element repeated N times.Example 1:Input: [1,2,3,3]Output: 3Example 2:Input: [2,1,2,5,3,2]Output: 2Example 3:Input: [5,1,5,2,5,3,5,4]Output: 5*/func repeatedNTimes(A []int) int &#123; mp := map[int]int&#123;&#125; for _, v := range A&#123; if _, ok := mp[v]; ok&#123; return v &#125; mp[v] = 1 &#125; return 0&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jewels and Stones(771)]]></title>
    <url>%2F2020%2F05%2F23%2FJewels-and-Stones-771%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425/*Example 1:Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;Output: 3Example 2:Input: J = &quot;z&quot;, S = &quot;ZZ&quot;Output: 0*/func numJewelsInStones(J string, S string) int &#123; if len(S) == 0 || len(J) == 0&#123; return 0 &#125; jMap := make(map[rune]bool, len(J)) for _, j := range J&#123; jMap[j] = true &#125; result := 0 for _, s := range S&#123; if jMap[s]&#123; result++ &#125; &#125; return result&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>hash table</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Longest Univalue Path(687)]]></title>
    <url>%2F2020%2F05%2F22%2FLongest-Univalue-Path-687%2F</url>
    <content type="text"><![CDATA[12345678910111213/*Given a binary tree, find the length of the longest path where each node inthe path has the same value. This path may or may not pass through the root.The length of path between two nodes is represented by the number of edges between them.Example 1:Input: 5 / \ 4 5 / \ \ 1 1 5Output: 2 123456789101112131415161718192021222324252627282930313233343536373839404142434445Example 2:Input: 1 / \ 4 5 / \ \ 4 4 5Output: 2*/func longestUnivaluePath(root *TreeNode) int &#123; if root == nil &#123; return 0 &#125; max := 0 helper(root, root.Val, &amp;max) return max&#125;func helper(root *TreeNode, pre int, max *int) int &#123; if root == nil &#123; return 0 &#125; left := helper(root.Left, root.Val, max) right := helper(root.Right, root.Val, max) *max = maxVal(*max, left+right) if root.Val == pre &#123; return maxVal(left, right) + 1 &#125; return 0&#125;func maxVal(a, b int) int &#123; if a &gt;= b &#123; return a &#125; return b&#125;//TreeNode 树节点type TreeNode struct &#123; Val int // 值 Left *TreeNode // 左节点 Right *TreeNode // 右节点&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum Depth of Binary Tree(111)]]></title>
    <url>%2F2020%2F05%2F21%2FMinimum-Depth-of-Binary-Tree-111%2F</url>
    <content type="text"><![CDATA[12345678910111213/*Given a binary tree, find its minimum depth.The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.Note: A leaf is a node with no children.Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its minimum depth = 2.*/ 12345678910111213141516171819202122232425262728293031func minDepth(root *TreeNode) int &#123; if root == nil&#123; return 0 &#125; left := minDepth(root.Left) right := minDepth(root.Right) if left == 0 || right == 0&#123; return 1 + maxVal(left, right) &#125; return 1 + minVal(left, right)&#125;func maxVal(a, b int) int&#123; if a &gt;= b&#123; return a &#125; return b&#125;func minVal(a, b int) int&#123; if a &gt;= b&#123; return b &#125; return a&#125;type TreeNode struct&#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Path Sum(112)]]></title>
    <url>%2F2020%2F04%2F18%2FPath-Sum-112%2F</url>
    <content type="text"><![CDATA[12345678910111213141516/*Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.Note: A leaf is a node with no children.Example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.*/ 12345678910111213141516func hasPathSum(root *TreeNode, sum int) bool &#123; if root == nil&#123; return false &#125; if root.Left == nil &amp;&amp; root.Right == nil &amp;&amp; root.Val == sum&#123; return true &#125; return hasPathSum(root.Left, sum - root.Val) || hasPathSum(root.Right, sum - root.Val)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find Mode in Binary Search Tree(501)]]></title>
    <url>%2F2020%2F04%2F17%2FFind-Mode-in-Binary-Search-Tree-501%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*Given a binary search tree (BST) with duplicates, find all the mode(s) (the most frequently occurred element) in the given BST.Assume a BST is defined as follows:The left subtree of a node contains only nodes with keys less than or equal to the node&apos;s key.The right subtree of a node contains only nodes with keys greater than or equal to the node&apos;s key.Both the left and right subtrees must also be binary search trees.For example:Given BST [1,null,2,2], 1 \ 2 / 2 return [2].*/func findMode(root *TreeNode) []int &#123; if root == nil&#123; return []int&#123;&#125; &#125; max := 0 res := []int&#123;&#125; tmp := make(map[int]int) tmp = helper(root, tmp) for _, v := range tmp&#123; if v &gt; max&#123; max = v &#125; &#125; for i, v := range tmp&#123; if v == max&#123; res = append(res, i) &#125; &#125; return res&#125;func helper(root *TreeNode, tmp map[int]int) map[int]int&#123; if root == nil&#123; return tmp &#125; tmp[root.Val]++ helper(root.Left, tmp) helper(root.Right, tmp) return tmp&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Balanced Binary Tree(110)]]></title>
    <url>%2F2020%2F04%2F16%2FBalanced-Binary-Tree-110%2F</url>
    <content type="text"><![CDATA[12345678910111213/*Given a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as:a binary tree in which the left and right subtrees of every node differ in height by no more than 1.Example 1:Given the following tree [3,9,20,null,null,15,7]: 3 / \ 9 20 / \ 15 7Return true. 12345678910111213141516171819202122232425262728293031323334353637383940Example 2:Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \ 2 2 / \ 3 3 / \ 4 4Return false.*/func isBalanced(root *TreeNode) bool &#123; return maxDepLen(root) != -1&#125;func maxDepLen(node *TreeNode) int&#123; if node == nil&#123; return 0 &#125; left := maxDepLen(node.Left) right := maxDepLen(node.Right) if left == -1 || right == -1 || left - right &gt; 1 || right - left &gt; 1&#123; return -1 &#125; return 1 + maxVal(left, right)&#125;func maxVal(a, b int) int&#123; if a &gt; b&#123; return a &#125; return b&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Subtree of Another Tree(572)]]></title>
    <url>%2F2020%2F04%2F15%2FSubtree-of-Another-Tree-572%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819/*Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node&apos;s descendants. The tree s could also be considered as a subtree of itself.Example 1:Given tree s: 3 / \ 4 5 / \ 1 2Given tree t: 4 / \ 1 2Return true, because t has the same structure and node values with a subtree of s. 123456789101112131415161718192021222324252627282930313233343536373839404142Example 2:Given tree s: 3 / \ 4 5 / \ 1 2 / 0Given tree t: 4 / \ 1 2Return false.*/func isSubtree(s *TreeNode, t *TreeNode) bool &#123; if s == nil&#123; return false &#125; if isEqual(s, t)&#123; return true &#125; return isSubtree(s.Left, t) || isSubtree(s.Right, t)&#125;func isEqual(s *TreeNode, t *TreeNode) bool&#123; if s == t&#123; return true &#125; if s == nil || t == nil&#123; return false &#125; return s.Val == t.Val &amp;&amp; isEqual(s.Left, t.Left) &amp;&amp; isEqual(s.Right, t.Right)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Path Sum III(437)]]></title>
    <url>%2F2020%2F04%2F14%2FPath-Sum-III-437%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223/*You are given a binary tree in which each node contains an integer value.Find the number of paths that sum to a given value.The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.Example:root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \ 5 -3 / \ \ 3 2 11 / \ \3 -2 1Return 3. The paths that sum to 8 are:1. 5 -&gt; 32. 5 -&gt; 2 -&gt; 13. -3 -&gt; 11*/ 12345678910111213141516171819202122232425262728func pathSum(root *TreeNode, sum int) int &#123; if root == nil&#123; return 0 &#125; return helper(root, sum) + pathSum(root.Left, sum) + pathSum(root.Right, sum)&#125;func helper(root *TreeNode, sum int) int &#123; if root == nil&#123; return 0 &#125; sum = sum - root.Val l := helper(root.Left, sum) r := helper(root.Right, sum) if sum == 0&#123; return 1 + l + r &#125; return l + r&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Symmetric Tree(101)]]></title>
    <url>%2F2020%2F04%2F13%2FSymmetric-Tree-101%2F</url>
    <content type="text"><![CDATA[12345678910111213141516/*Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \3 4 4 3But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3*/ 12345678910111213141516171819202122func isSymmetric(root *TreeNode) bool &#123; if root == nil&#123; return true &#125; return isS(root.Left, root.Right)&#125;func isS(l, r *TreeNode) bool&#123; if l == nil || r == nil&#123; return l == r &#125; if l.Val != r.Val&#123; return false &#125; return isS(l.Right, r.Left) &amp;&amp; isS(l.Left, r.Right)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Diameter of Binary Tree(543)]]></title>
    <url>%2F2020%2F04%2F11%2FDiameter-of-Binary-Tree-543%2F</url>
    <content type="text"><![CDATA[1234567891011121314/*Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.Example:Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].*/ 1234567891011121314151617181920212223242526272829var maxDiameter int = 0func diameterOfBinaryTree(root *TreeNode) int &#123; maxDiameter = 0 helper(root) return maxDiameter&#125;func helper(node *TreeNode) int&#123; if node == nil&#123; return 0 &#125; leftDiameter := helper(node.Left) rightDiameter := helper(node.Right) maxDiameter = maxVal(maxDiameter, leftDiameter + rightDiameter) return 1 + maxVal(leftDiameter, rightDiameter)&#125;func maxVal(a, b int) int&#123; if a &gt; b&#123; return a &#125; return b&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lowest Common Ancestor of a Binary Search Tree(235)]]></title>
    <url>%2F2020%2F04%2F10%2FLowest-Common-Ancestor-of-a-Binary-Search-Tree-235%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021/*最低公共祖先*/func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode &#123; for cur := root; cur != nil; &#123; if cur.Val &gt; p.Val &amp;&amp; cur.Val &gt; q.Val&#123; cur = cur.Left &#125; else if cur.Val &lt; p.Val &amp;&amp; cur.Val &lt; q.Val&#123; cur = cur.Right &#125; else &#123; return cur &#125; &#125; return nil&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree Paths(257)]]></title>
    <url>%2F2020%2F04%2F09%2FBinary-Tree-Paths-257%2F</url>
    <content type="text"><![CDATA[123456789101112131415/*Given a binary tree, return all root-to-leaf paths.Note: A leaf is a node with no children.Example:Input: 1 / \2 3 \ 5Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3*/ 1234567891011121314151617181920212223242526272829func binaryTreePaths(root *TreeNode) []string &#123; if root == nil&#123; return []string&#123;&#125; &#125; paths := make([]string, 0) helper(root, strconv.Itoa(root.Val), &amp;paths) return paths&#125;func helper(root *TreeNode, path string, paths *[]string)&#123; if root.Left == nil &amp;&amp; root.Right == nil&#123; *paths = append(*paths, path) &#125; if root.Right != nil&#123; helper(root.Right, path + &quot;-&gt;&quot; + strconv.Itoa(root.Right.Val), paths) &#125; if root.Left != nil&#123; helper(root.Left, path + &quot;-&gt;&quot; + strconv.Itoa(root.Left.Val), paths) &#125;&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binary Tree Level Order Traversal II(107)]]></title>
    <url>%2F2020%2F04%2F07%2FBinary-Tree-Level-Order-Traversal-II-107%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920/*Given a binary tree, return the bottom-up level order traversal of its nodes&apos; values. (ie, from left to right, level by level from leaf to root).For example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7return its bottom-up level order traversal as:[ [15,7], [9,20], [3]]*/ 1234567891011121314151617181920212223242526func levelOrderBottom(root *TreeNode) [][]int &#123; if root == nil&#123; return nil &#125; traversal := make([][]int, 0) helper(root, 0, &amp;traversal) return traversal&#125;func helper(root *TreeNode, level int, traversal *[][]int)&#123; if root == nil&#123; return &#125; if len(*traversal) &lt; level + 1&#123; *traversal = append([][]int&#123;&#123;&#125;&#125;, *traversal...) &#125; helper(root.Left, level+1, traversal) helper(root.Right, level+1, traversal) (*traversal)[len(*traversal)-level-1] = append((*traversal)[len(*traversal)-level-1], root.Val)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum Distance Between BST Nodes(783)]]></title>
    <url>%2F2020%2F04%2F05%2FMinimum-Distance-Between-BST-Nodes-783%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021/*Given a Binary Search Tree (BST) with the root node root, return the minimum difference between the values of any two different nodes in the tree.Example :Input: root = [4,2,6,1,3,null,null]Output: 1Explanation:Note that root is a TreeNode object, not an array.The given tree [4,2,6,1,3,null,null] is represented by the following diagram: 4 / \ 2 6 / \ 1 3 while the minimum difference in this tree is 1, it occurs between node 1 and node 2, also between node 3 and node 2.*/ 123456789101112131415161718192021222324252627282930313233func minDiffInBST(root *TreeNode) int &#123; diff, _, _ := helper(root) return diff&#125;func helper(node *TreeNode) (int, int, int)&#123; lDiff, rDiff, max, min := math.MaxInt32, math.MaxInt32, node.Val, node.Val if node.Left != nil&#123; lDiffVal, lMaxVal, lMinVal := helper(node.Left) min = lMinVal lDiff = minVal(lDiffVal, node.Val - lMaxVal) &#125; if node.Right != nil&#123; rDiffVal, rMaxVal, rMinVal := helper(node.Right) max = rMaxVal rDiff = minVal(rDiffVal, rMinVal - node.Val) &#125; return minVal(lDiff, rDiff), max, min&#125;func minVal(a, b int) int&#123; if a &gt; b&#123; return b &#125; return a&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Same Tree(100)]]></title>
    <url>%2F2020%2F04%2F04%2FSame-Tree-100%2F</url>
    <content type="text"><![CDATA[12345678910111213/*Given two binary trees, write a function to check if they are the same or not.Two binary trees are considered the same if they are structurally identical and the nodes have the same value.Example 1:Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]Output: trueExample 2: 1234567891011121314151617181920212223242526272829303132Input: 1 1 / \ 2 2 [1,2], [1,null,2]Output: falseExample 3:Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]Output: false*/func isSameTree(p *TreeNode, q *TreeNode) bool &#123; if p == nil &amp;&amp; q == nil&#123; return true &#125; else if p == nil || q == nil || p.Val != q.Val &#123; return false &#125; else &#123; return isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(p.Right, q.Right) &#125;&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cousins in Binary Tree(993)]]></title>
    <url>%2F2020%2F04%2F04%2FCousins-in-Binary-Tree-993%2F</url>
    <content type="text"><![CDATA[123456/*In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.Two nodes of a binary tree are cousins if they have the same depth, but have different parents.We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree.Return true if and only if the nodes corresponding to the values x and y are cousins.*/ 123456789101112131415161718192021222324252627var xParent, yParent, xDepth, yDepth intfunc isCousins(root *TreeNode, x int, y int) bool &#123; helper(root, x, y, 0, 0) return xDepth == yDepth &amp;&amp; xParent != yParent&#125;func helper(root *TreeNode, x, y, parent, depth int)&#123; if root == nil&#123; return &#125; if root.Val == x&#123; xParent = parent xDepth = depth &#125; if root.Val == y&#123; yParent = parent yDepth = depth &#125; helper(root.Left, x, y, root.Val, depth+1) helper(root.Right, x, y, root.Val, depth+1)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minimum Absolute Difference in BST(530)]]></title>
    <url>%2F2020%2F04%2F04%2FMinimum-Absolute-Difference-in-BST-530%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617/*Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.Example:Input: 1 \ 3 / 2Output:1Explanation:The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).*/ 1234567891011121314151617181920212223242526272829303132333435func getMinimumDifference(root *TreeNode) int &#123; _, _, diff := helper(root) return diff&#125;func helper(root *TreeNode) (int, int, int)&#123; min, max, diff := root.Val, root.Val, math.MaxInt32 if root.Left != nil&#123; lMin, lMax, lDiff := helper(root.Left) min = lMin if tmpDiff := root.Val - lMax; tmpDiff &lt; diff&#123; diff = tmpDiff &#125; if lDiff &lt; diff&#123; diff = lDiff &#125; &#125; if root.Right != nil&#123; rMin, rMax, rDiff := helper(root.Right) max = rMax if tmpDiff := rMin - root.Val; tmpDiff &lt; diff&#123; diff = tmpDiff &#125; if rDiff &lt; diff&#123; diff = rDiff &#125; &#125; return min, max, diff&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convert BST to Greater Tree(538)]]></title>
    <url>%2F2020%2F04%2F02%2FConvert-BST-to-Greater-Tree-538%2F</url>
    <content type="text"><![CDATA[123456789101112131415/*Given a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.Example:Input: The root of a Binary Search Tree like this: 5 / \ 2 13Output: The root of a Greater Tree like this: 18 / \ 20 13*/ 12345678910111213141516171819202122232425var sum intfunc convertBST(root *TreeNode) *TreeNode &#123; if root == nil&#123; return nil &#125; sum = 0 convert(root) return root&#125;func convert(root *TreeNode)&#123; if root == nil&#123; return &#125; convert(root.Right) root.Val += sum sum = root.Val convert(root.Left)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Sum IV - Input is a BST(653)]]></title>
    <url>%2F2020%2F04%2F01%2FTwo-Sum-IV-Input-is-a-BST-653%2F</url>
    <content type="text"><![CDATA[12345678910111213/*Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.Example 1:Input: 5 / \ 3 6 / \ \2 4 7Target = 9Output: True 1234567891011121314151617181920212223242526272829303132Example 2:Input: 5 / \ 3 6 / \ \2 4 7Target = 28Output: False*/func findTarget(root *TreeNode, k int) bool &#123; var sumMap = make(map[int]bool) return dfs(root, k, sumMap)&#125;func dfs(root *TreeNode, k int, sumMap map[int]bool) bool&#123; if root == nil&#123; return false &#125; if _, ok := sumMap[root.Val]; ok&#123; return true &#125; sumMap[k - root.Val] = true return dfs(root.Left, k, sumMap) || dfs(root.Right, k, sumMap)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Convert Sorted Array to Binary Search Tree(108)]]></title>
    <url>%2F2020%2F04%2F01%2FConvert-Sorted-Array-to-Binary-Search-Tree-108%2F</url>
    <content type="text"><![CDATA[1234567891011121314/*Given an array where elements are sorted in ascending order, convert it to a height balanced BST.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.Example:Given the sorted array: [-10,-3,0,5,9],One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5*/ 123456789101112131415161718func sortedArrayToBST(nums []int) *TreeNode &#123; if len(nums) == 0&#123; return nil &#125; middle := len(nums)/2 return &amp;TreeNode&#123; Val : nums[middle], Left : sortedArrayToBST(nums[:middle]), Right : sortedArrayToBST(nums[middle+1:]), &#125;&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Average of Levels in Binary Tree(637)]]></title>
    <url>%2F2020%2F03%2F30%2FAverage-of-Levels-in-Binary-Tree-637%2F</url>
    <content type="text"><![CDATA[123456789101112131415/*Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.Example 1:Input: 3 / \ 9 20 / \ 15 7Output: [3, 14.5, 11]Explanation:The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].*/ 123456789101112131415161718192021222324252627282930func averageOfLevels(root *TreeNode) []float64 &#123; av := []float64&#123;&#125; curr := []*TreeNode&#123;&#125; next := []*TreeNode&#123;&#125; curr = append(curr, root) for len(curr) != 0&#123; sum := 0 for i := 0; i &lt; len(curr); i++&#123; sum += curr[i].Val if curr[i].Left != nil&#123; next = append(next, curr[i].Left) &#125; if curr[i].Right != nil&#123; next = append(next, curr[i].Right) &#125; &#125; av = append(av, float64(sum)/float64(len(curr))) curr = next next = []*TreeNode&#123;&#125; &#125; return av&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sum of Left Leaves(404)]]></title>
    <url>%2F2020%2F03%2F29%2FSum-of-Left-Leaves-404%2F</url>
    <content type="text"><![CDATA[1234567891011/*Find the sum of all left leaves in a given binary tree.Example: 3 / \ 9 20 / \ 15 7There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 123456789101112131415161718192021222324252627*/func sumOfLeftLeaves(root *TreeNode) int &#123; if root == nil&#123; return 0 &#125; ret := 0 help(root.Left, &amp;ret, true) help(root.Right, &amp;ret, false) return ret&#125;func help(node *TreeNode, ret *int, left bool)&#123; if node == nil&#123; return &#125; if node.Left == nil &amp;&amp; node.Right == nil &amp;&amp; left&#123; *ret += node.Val &#125; help(node.Left, ret, true) help(node.Right, ret, false)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trim a Binary Search Tree(669)]]></title>
    <url>%2F2020%2F03%2F28%2FTrim-a-Binary-Search-Tree-669%2F</url>
    <content type="text"><![CDATA[12345678910111213141516/*Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.Example 1:Input: 1 / \ 0 2 L = 1 R = 2Output: 1 \ 2 1234567891011121314151617181920212223242526272829303132333435363738394041Example 2:Input: 3 / \ 0 4 \ 2 / 1 L = 1 R = 3Output: 3 / 2 / 1*/func trimBST(root *TreeNode, L int, R int) *TreeNode &#123; if root == nil&#123; return root &#125; if root.Val &gt;= L &amp;&amp; root.Val &lt;= R&#123; root.Left = trimBST(root.Left, L, R) root.Right = trimBST(root.Right, L, R) return root &#125; tmp := root if root.Val &lt; L&#123; tmp = root.Right &#125; else if root.Val &gt; R&#123; tmp = root.Left &#125; return trimBST(tmp, L, R)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Invert Binary Tree(226)]]></title>
    <url>%2F2020%2F03%2F28%2FInvert-Binary-Tree-226%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617/*Invert a binary tree.Example:Input: 4 / \ 2 7 / \ / \1 3 6 9Output: 4 / \ 7 2 / \ / \9 6 3 1*/ 123456789101112131415func invertTree(root *TreeNode) *TreeNode &#123; if root == nil&#123; return nil &#125; invertTree(root.Left) invertTree(root.Right) root.Left, root.Right = root.Right, root.Left return root&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Depth of Binary Tree(104)]]></title>
    <url>%2F2020%2F03%2F27%2FMaximum-Depth-of-Binary-Tree-104%2F</url>
    <content type="text"><![CDATA[1234567891011121314/*Given a binary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.Note: A leaf is a node with no children.Example:Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7*/ 123456789101112131415161718func maxDepth(root *TreeNode) int &#123; if root == nil&#123; return 0 &#125; left := maxDepth(root.Left) right := maxDepth(root.Right) if left &gt; right&#123; return left + 1 &#125; else&#123; return right + 1 &#125;&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leaf-Similar Trees(872)]]></title>
    <url>%2F2020%2F03%2F27%2FLeaf-Similar-Trees-872%2F</url>
    <content type="text"><![CDATA[1234567/*Consider all the leaves of a binary tree. From left to right order, the values of those leaves form a leaf value sequence.For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).Two binary trees are considered leaf-similar if their leaf value sequence is the same.Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.*/ 12345678910111213141516171819202122232425func leafSimilar(root1 *TreeNode, root2 *TreeNode) bool &#123; var leaf1, leaf2 []int dfs(root1, &amp;leaf1) dfs(root2, &amp;leaf2) return reflect.DeepEqual(leaf1, leaf2)&#125;func dfs(node *TreeNode, leafNodes *[]int)&#123; if node == nil&#123; return &#125; if node.Right == nil &amp;&amp; node.Left == nil&#123; *leafNodes = append(*leafNodes, node.Val) return &#125; dfs(node.Left, leafNodes) dfs(node.Right, leafNodes)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sum of Root To Leaf Binary Numbers(1022)]]></title>
    <url>%2F2020%2F03%2F26%2FSum-of-Root-To-Leaf-Binary-Numbers-1022%2F</url>
    <content type="text"><![CDATA[1234567/*Given a binary tree, each node has value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13.For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.Return the sum of these numbers.*/ func sumRootToLeaf(root *TreeNode) int { if root != nil{ return dfs(root, 0) } return 0 } func dfs(node *TreeNode, value int) int{ current := (value &lt;&lt; 1) + node.Val if node.Left == nil &amp;&amp; node.Right == nil{ return current } sum := 0 if node.Left != nil{ sum += dfs(node.Left, current) } if node.Right != nil{ sum += dfs(node.Right, current) } return sum } type TreeNode struct { Val int Left *TreeNode Right *TreeNode }]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Univalued Binary Tree(965)]]></title>
    <url>%2F2020%2F03%2F24%2FUnivalued-Binary-Tree-965%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324/*A binary tree is univalued if every node in the tree has the same value.Return true if and only if the given tree is univalued.*/func isUnivalTree(root *TreeNode) bool &#123; val := root.Val return isEqual(root.Left, val) &amp;&amp; isEqual(root.Right, val)&#125;func isEqual(root *TreeNode, val int) bool&#123; if root == nil&#123; return true &#125; if root.Val == val&#123; return isEqual(root.Left, val) &amp;&amp; isEqual(root.Right, val) &#125; return false&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Depth of N-ary Tree(559)]]></title>
    <url>%2F2020%2F03%2F24%2FMaximum-Depth-of-N-ary-Tree-559%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617/*Given a n-ary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).*/func maxDepth(root *Node) int &#123; if root == nil&#123; return 0 &#125; m := 1 for _, v := range root.Children&#123; m = max(m, maxDepth(v)+1) &#125; return m&#125; 1234567891011func max(a, b int) int&#123; if a &gt; b&#123; return a &#125; return b&#125;type Node struct &#123; Val int Children []*Node&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Increasing Order Search Tree(897)]]></title>
    <url>%2F2020%2F03%2F23%2FIncreasing-Order-Search-Tree-897%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829/*Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.*/func increasingBST(root *TreeNode) *TreeNode &#123; path := []int&#123;&#125; inOrder(root, &amp;path) var next *TreeNode for i := len(path) - 1; i &gt;= 0; i--&#123; tmp := &amp;TreeNode&#123;path[i], nil, next&#125; next = tmp &#125; return next&#125;func inOrder(root *TreeNode, path *[]int)&#123; if root == nil&#123; return &#125; inOrder(root.Left, path) *path = append(*path, root.Val) inOrder(root.Right, path)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Search in a Binary Search Tree(700)]]></title>
    <url>%2F2020%2F03%2F23%2FSearch-in-a-Binary-Search-Tree-700%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617/*Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node&apos;s value equals the given value. Return the subtree rooted with that node. If such node doesn&apos;t exist, you should return NULL.*/func searchBST(root *TreeNode, val int) *TreeNode &#123; if root == nil&#123; return nil &#125; if root.Val == val&#123; return root &#125; if root.Val &lt; val&#123; return searchBST(root.Right, val) &#125; else&#123; return searchBST(root.Left, val) &#125;&#125; 123456789101112131415161718func searchBST2(root *TreeNode, val int) *TreeNode&#123; for root != nil&#123; if root.Val == val&#123; return root &#125; else if root.Val &lt; val&#123; root = root.Right &#125; else&#123; root = root.Left &#125; &#125; return nil&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N-ary Tree Preorder Traversal(589)]]></title>
    <url>%2F2020%2F03%2F22%2FN-ary-Tree-Preorder-Traversal-589%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819Given an n-ary tree, return the preorder traversal of its nodes&apos; values.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).class Solution &#123; public List&lt;Integer&gt; preorder(Node root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); preorder(root, list); return list; &#125; private void preorder(Node node, List&lt;Integer&gt; list)&#123; if(node != null)&#123; list.add(node.val); for(Node n : node.children)&#123; preorder(n, list); &#125; &#125; &#125;&#125; 123456789101112131415class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N-ary Tree Postorder Traversal(590)]]></title>
    <url>%2F2020%2F03%2F19%2FN-ary-Tree-Postorder-Traversal-590%2F</url>
    <content type="text"><![CDATA[12345/*Given an n-ary tree, return the postorder traversal of its nodes&apos; values.Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).层序遍历*/ 123456789101112131415161718192021222324252627282930class Node &#123; public int val; public List&lt;Node&gt; children; public Node() &#123;&#125; public Node(int _val) &#123; val = _val; &#125; public Node(int _val, List&lt;Node&gt; _children) &#123; val = _val; children = _children; &#125;&#125;public class Solution&#123; public List&lt;Integer&gt; postorder(Node node)&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(node == null) return list; postorder(node, list); return list; &#125; public void postorder(Node node, List&lt;Integer&gt; list)&#123; if(node == null) return ; for(Node child : node.children)&#123; postorder(child, list); &#125; list.add(node.val); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Merge Two Binary Trees(617)]]></title>
    <url>%2F2020%2F03%2F16%2FMerge-Two-Binary-Trees-617%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819/*Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.*/func mergeTrees(t1 *TreeNode, t2 *TreeNode) *TreeNode &#123; if t1 == nil&#123; return t2 &#125; if t2 == nil&#123; return t1 &#125; return &amp;TreeNode&#123;t1.Val+t2.Val, mergeTrees(t1.Left, t2.Left), mergeTrees(t1.Right, t2.Right)&#125;&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Range Sum of BST(938)]]></title>
    <url>%2F2020%2F03%2F15%2FRange-Sum-of-BST-938%2F</url>
    <content type="text"><![CDATA[12345678910/*Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).The binary search tree is guaranteed to have unique values.Example 1:Input: root = [10,5,15,3,7,null,18], L = 7, R = 15Output: 32Example 2:Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10Output: 23*/ 12345678910111213141516171819func rangeSumBST(root *TreeNode, L int, R int) int &#123; if root == nil&#123; return 0 &#125; if root.Val &gt; R&#123; return rangeSumBST(root.Left, L, R) &#125; if root.Val &lt; L&#123; return rangeSumBST(root.Right, L, R) &#125; return root.Val + rangeSumBST(root.Left, L, R) + rangeSumBST(root.Right, L, R)&#125;type TreeNode struct &#123; Val int Left *TreeNode Right *TreeNode&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>tree</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行时数据区域]]></title>
    <url>%2F2020%2F03%2F11%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2FJava_%E8%99%9A%E6%8B%9F%E6%9C%BA%2F%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[运行时数据区域程序计数器（Program Counter Register） 当前线程所执行的字节码行号指示器（逻辑） 通过改变计数器的值来选取下一条需要执行的字节码指令 和线程一对一的关系，即“线程私有” 对 Java 方法计数，如果是 Native 方法则计数器值为 Undefined 只是计数，不会发生内存泄漏 Java 虚拟机栈每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小： java -Xss512M HackTheJava 该区域可能抛出以下异常： * 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； * 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。本地方法栈本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。 堆所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块： 新生代（Young Generation） 老年代（Old Generation）堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 堆和栈的联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址。 栈和堆的区别： 物理地址 堆的物理内存分配是不连续的； 栈的物理内存分配是连续的 分配内存 堆是不连续的，分配的内存是在运行期确定的，大小不固定； 栈是连续的，分配的内存在编译器就已经确定，大小固定 存放内容 堆中存放的是对象和数组，关注的是数据的存储； 栈中存放局部变量，关注的是程序方法的执行 是否线程私有 堆内存中的对象对所有线程可见，可被所有线程访问； 栈内存属于某个线程私有的 异常 栈扩展失败，会抛出 StackOverflowError； 堆内存不足，会抛出 OutOfMemoryError方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。 HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。 元空间（MetaSpace）与永久代（PermGen）的区别： 元空间使用本地内存，而永久代使用 JVM 的内存。 元空间（MetaSpace）相比永久代（PermGen）的优势： * 字符串常量池存在永久代中，容易出现性能问题和内存溢出 * 类和方法的信息大小难以确定，给永久代的大小指定带来困难 * 永久代会为 GC 带来不必要的复杂性运行时常量池运行时常量池是方法区的一部分。 Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。 直接内存 在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。]]></content>
      <categories>
        <category>技术总览</category>
        <category>Java</category>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Climbing Stairs(70)]]></title>
    <url>%2F2020%2F03%2F11%2FClimbing-Stairs-70%2F</url>
    <content type="text"><![CDATA[12345678910/*You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?Note: Given n will be a positive integer.Example 1:Input: 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps 123456789101112131415161718Example 2:Input: 3Output: 3Explanation: There are three ways to climb to the top.1. 1 step + 1 step + 1 step2. 1 step + 2 steps3. 2 steps + 1 step*/func climbStairs(n int) int &#123; if n &lt;= 2&#123; return n &#125; dp1, dp2 := 1, 2 for i := 2; i &lt; n; i++&#123; dp1, dp2 = dp2, dp1+dp2 &#125; return dp2&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>dynamic programming</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Is Subsequence(392)]]></title>
    <url>%2F2020%2F03%2F10%2FIs-Subsequence-392%2F</url>
    <content type="text"><![CDATA[1234567891011/*Given a string s and a string t, check if s is subsequence of t.You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100).A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ace&quot; is a subsequence of &quot;abcde&quot; while &quot;aec&quot; is not).Example 1:s = &quot;abc&quot;, t = &quot;ahbgdc&quot;Return true.Example 2:s = &quot;axc&quot;, t = &quot;ahbgdc&quot;Return false.*/ 123456789101112131415func isSubsequence(s string, t string) bool &#123; curIndex, maxIndex := 0, len(s) if maxIndex == 0&#123; return true &#125; for i := 0; i &lt; len(t); i++&#123; if t[i] == s[curIndex]&#123; curIndex++ &#125; if curIndex == maxIndex&#123; return true &#125; &#125; return false&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>dynamic programming</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各消息中间件]]></title>
    <url>%2F2020%2F03%2F05%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FRabbitMQ%2F%E5%90%84%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[ActiveMQActiveMQ 是 Apache 出品的最流行的、性能强劲的开源消息总线，并且其是一个完全支持 JMS 规范的消息中间件。其丰富的 API、多种集群构建模式使得它成为业界老牌消息中间件，广泛应用于中小型企业。KafkaKafka 是 LinkedIn 开源的分布式发布-订阅消息系统，目前属于 Apache 顶级项目。 Kafka 主要特点是基于 Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8 版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。 RocketMQRocketMQ 是阿里开源的消息中间件，目前也已经孵化为 Apache 顶级项目，它是纯 Java 开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。 RocketMQ 思路起源于 Kafka，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog 分发等场景。 RabbitMQRabbitMQ 是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议来实现。 AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。 对比 消息中间件 ActiveMQ Kafka RocketMQ RabbitMQ 吞吐量 万数量级 十万级，高吞吐 十万级，高吞吐 万数量级 Topic 数量对吞吐量影响 / Topic 从几十到几百时，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 Topic 数量不要过多，如果要支撑大规模的 Topic，需要增加更多的机器 Topic 可达百/千级，吞吐量下降幅度小在同等机器下，可以支撑大量的 Topic / 时效性 毫秒级 毫秒级 毫秒级 微秒级 可用性 高 基于主从架构实现高可用高 非常高 分布式架构 非常高 分布式架构 高 基于主从架构实现高可用高 可靠性 丢失数据的概率低 优化参数配置，可以做到零丢失 优化参数配置，可以做到零丢失 基本不会丢失数据 功能 功能较完备 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 MQ 功能较为完善，还是分布式的，扩展性好 基于 ErLang 开发，并发能力很强，性能极好，延时很低]]></content>
      <categories>
        <category>技术总览</category>
        <category>中间件</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZooKeeper概述]]></title>
    <url>%2F2020%2F03%2F05%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FZooKeeper%2FZooKeeper%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[ZooKeeper概要Zookeeper是一个分布式数据一致性的解决方案，致力于提供一个高性能、高可用、且具有严格的顺序访问控制能力的分布式协调系统。产生背景随着互联网时代的发展项目已经从单体项目到现在的分布式项目，部署在多个服务器上随着而来产生多个节点之间的协同问题* 各个项目之间的RPC调用如何进行服务发现 * 如何保证任务在那个节点执行 * 如何保证并发请求的幂等 * 如何保证容错... 这些问题可以统一归纳为多节点协调问题，如果靠节点自身进行协调这是非常不可靠的，性能上也不可取。 必须由一个独立的服务做协调工作，它必须可靠，而且保证性能。 ZooKeeper的作用* 数据发布与订阅（配置中心） * 负载均衡 * 命名服务(Naming Service) * 分布式通知/协调 * 集群管理与Master选举 * 分布式锁 * 分布式队列 ...ZooKeeper的特点顺序一致性： 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。 原子性： 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。 单一系统映像 ： 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。 可靠性： 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。 参考：[github](https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/framework/ZooKeeper.md) [github](https://github.com/qiurunze123/zookeeperDesign) [zookeeper](https://zookeeper.apache.org/doc/current/index.html)]]></content>
      <categories>
        <category>技术总览</category>
        <category>中间件</category>
        <category>ZooKeeper</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Third Maximum Number(414)]]></title>
    <url>%2F2020%2F03%2F04%2FThird-Maximum-Number-414%2F</url>
    <content type="text"><![CDATA[### 123456789101112/*Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).Example 1:Input: [3, 2, 1]Output: 1Explanation: The third maximum is 1.Example 2:Input: [1, 2]Output: 2Explanation: The third maximum does not exist, so the maximum (2) is returned instead.*/ 1234567891011121314151617func thirdMax(nums []int) int &#123; min := ^(1&lt;&lt;32)+1 a, b, c := min, min, min for i := 0; i &lt; len(nums); i++&#123; if nums[i] &gt; a&#123; a, b, c = nums[i], a, b &#125; else if nums[i] &gt; b &amp;&amp; nums[i] &lt; a&#123; b, c = nums[i], b &#125; else if nums[i] &gt; c &amp;&amp; nums[i] &lt; b&#123; c = nums[i] &#125; &#125; if c == min&#123; return a &#125; return c&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式缓存的一致性哈希算法]]></title>
    <url>%2F2020%2F03%2F03%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%88%86%E5%B8%83%E5%BC%8F%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Hash 算法根据键值，首先计算哈希值，然后对节点数取模，然后映射在不同的 Master 节点上。一旦某一个 Master 节点宕机，当请求过来时，会基于最新的剩余 Master 节点数去取模，尝试去获取数据，导致大部分的请求过来，全部无法拿到有效的缓存，大量的流量涌入数据库。换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端数据库请求数据。 一致性 Hash 算法一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，假设某哈希函数 H 的值空间为0~2^32-1（即哈希值是一个32位无符号整形）。 整个空间按顺时针方向组织，圆环的正上方的点代表0，0 点右侧的第一个点代表1，以此类推，2、3 … 2^32-1，也就是说 0 点左侧的第一个点代表 2^32-1， 0 和 2^32-1 在零点中方向重合，我们把这个由 2^32 个点组成的圆环称为哈希环。 将各个服务器进行哈希，具体可以选择服务器的 IP 或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假设将 4 台服务器的 IP 地址哈希后在哈希环的位置如下： 接下来使用如下算法定位数据访问到相应服务器： 将数据键使用相同的函数 Hash 计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。 例如有 Object A、Object B、Object C、Object D 四个数据对象，经过哈希计算后，在哈希环上的位置如下： 根据一致性 Hash 算法： Object A 会被定位到 Node A 上； Object B 会被定位到 Node B 上； Object C 会被定位到 Node C 上； Object D 会被定位到 Node D 上。容错性和可扩展性假设 Node C 宕机，可以看到此时对象 A、B、D 不会受到影响，只有对象 C 被重定位到 Node D。 通常情况下，一致性 Hash 算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据不会受到影响。 下面考虑另外一种情况：如果在系统中增加一台服务器 Node X。 此时对象 A、B、D 不受影响，只有对象 C 需要重定位到新的Node X 。 通常情况下，一致性 Hash 算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。 综上所述，一致性 Hash 算法对于节点的增减都只需重定位哈希环中的一小部分数据，具有较好的容错性和可扩展性。 数据倾斜问题一致性 Hash 算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题。例如系统中只有 2 台服务器，如下所示： 此时必然造成大量数据集中到 Node A 上，而只有极少量会定位到 Node B 上。 为了解决这种数据倾斜问题，一致性 Hash 算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器 IP 或主机名的后面增加编号来实现。 例如针对上面的情况，可以为每台服务器计算 3 个虚拟节点： Node A 的 3 个虚拟节点：&quot;Node A#1&quot;、&quot;Node A#2&quot;、&quot;Node A#3&quot; Node B 的 3 个虚拟节点：&quot;Node B#1&quot;、&quot;Node B#2&quot;、&quot;Node B#3&quot;进行哈希计算后，六个虚拟节点在哈希环中的位置如下： 同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射过程，例如”Node A#1”、”Node A#2”、”Node A#3” 这 3 个虚拟节点的数据均定位到 Node A 上，解决了服务节点少时数据倾斜的问题。 在实际应用中，通常将虚拟节点数设置为 32 甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shortest Unsorted Continuous Subarray(581)]]></title>
    <url>%2F2020%2F03%2F03%2FShortest-Unsorted-Continuous-Subarray-581%2F</url>
    <content type="text"><![CDATA[Shortest Unsorted Continuous Subarray(581)1234567/*Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.Example 1:Input: [2, 6, 4, 8, 10, 9, 15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.*/ 1234567891011121314func findUnsortedSubarray(nums []int) int &#123; begin, end := -1, -2 for max, min, n, i := math.MinInt32, math.MaxInt32, len(nums), 0; i &lt; n; i++&#123; max, min = int(math.Max(float64(max), float64(nums[i]))), int(math.Min(float64(min), float64(nums[n-i-1]))) if nums[i] &lt; max&#123; end = i &#125; if nums[n-1-i] &gt; min&#123; begin = n - 1 - i &#125; &#125; return end - begin + 1&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valid Mountain Array(941)]]></title>
    <url>%2F2020%2F03%2F01%2FValid-Mountain-Array-941%2F</url>
    <content type="text"><![CDATA[Valid Mountain Array(941)123456789101112131415/*Given an array A of integers, return true if and only if it is a valid mountain array.Recall that A is a mountain array if and only if:Example 1:Input: [2,1]Output: falseExample 2:Input: [3,5,5]Output: falseExample 3:Input: [0,3,2,1]Output: true*/ 123456789101112131415161718192021func validMountainArray(A []int) bool &#123; if len(A) &lt; 3&#123; return false &#125; n := 2 for i := 1; i &lt; len(A)-1; i++&#123; begin := A[i] - A[i-1] end := A[i+1] - A[i] // 上峰点 if begin &gt; 0 &amp;&amp; end &lt; 0&#123; n-- &#125; // 下峰点、平点 if begin &lt; 0 &amp;&amp; end &gt; 0 || begin == 0 || end == 0&#123; return false &#125; &#125; return n == 1&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Average Subarray I(643)]]></title>
    <url>%2F2020%2F02%2F26%2FMaximum-Average-Subarray-I-643%2F</url>
    <content type="text"><![CDATA[Maximum Average Subarray I(643)12345678910/*Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.Example 1:Input: [1,12,-5,-6,50,3], k = 4Output: 12.75Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75Note:1 &lt;= k &lt;= n &lt;= 30,000.Elements of the given array will be in the range [-10,000, 10,000].*/ 123456789101112131415161718192021func findMaxAverage(nums []int, k int) float64 &#123; if len(nums) == 0&#123; return float64(0) &#125; if len(nums) == 1&#123; return float64(nums[0]) &#125; size := len(nums) var sum int for i := 0; i &lt; k; i++&#123; sum += nums[i] &#125; maxSum := sum; for i := k; i &lt; size; i++&#123; sum += nums[i] - nums[i-k] if sum &gt; maxSum&#123; maxSum = sum &#125; &#125; return float64(maxSum) / float64(k)&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Note]]></title>
    <url>%2F2020%2F02%2F25%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%2FWeb-Note%2F</url>
    <content type="text"><![CDATA[什么是Web框架Web Application Framework(网络应用框架),用于构建web应用：把HTTP的请求和响应，根据特定的规则对应到具体的处理函数上。把处理完的结果，传递到模板引擎上，通过网络协议传递给客户端。 * 接受并处理请求 * 响应结果具备的功能* 路由 * 控制器 * 配置 * 视图(模板引擎) * 数据库操作]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>常用框架</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Check If N and Its Double Exist(1346)]]></title>
    <url>%2F2020%2F02%2F25%2FCheck%20If%20N%20and%20Its%20Double%20Exist-1346%2F</url>
    <content type="text"><![CDATA[Check If N and Its Double Exist(1346)1234567891011121314151617/*Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M).More formally check if there exists two indices i and j such that :i != j0 &lt;= i, j &lt; arr.lengtharr[i] == 2 * arr[j]Example 1:Input: arr = [10,2,5,3]Output: trueExplanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5.Example 2:Input: arr = [7,1,14,11]Output: trueExplanation: N = 14 is the double of M = 7,that is, 14 = 2 * 7.Example 3: 1234567891011121314151617181920212223Input: arr = [3,1,7,11]Output: falseExplanation: In this case does not exist N and M, such that N = 2 * M.*/func checkIfExist(arr []int) bool &#123; exist := make(map[int]bool) for _, v := range arr&#123; _, ok := exist[v * 2] if ok&#123; return true &#125; if v % 2 == 0&#123; _, ok := exist[v / 2] if ok &#123; return true &#125; &#125; exist[v] = true &#125; return false&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximize Distance to Closest Person(849)]]></title>
    <url>%2F2020%2F02%2F24%2FMaximize-Distance-to-Closest-Person-849%2F</url>
    <content type="text"><![CDATA[Maximize Distance to Closest Person(849)12345/*In a row of seats, 1 represents a person sitting in that seat, and 0 represents that the seat is empty. There is at least one empty seat, and at least one person sitting.Alex wants to sit in the seat such that the distance between him and the closest person to him is maximized. Return that maximum distance to closest person. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162Example 1:Input: [1,0,0,0,1,0,1]Output: 2Explanation: If Alex sits in the second open seat (seats[2]), then the closest person has distance 2.If Alex sits in any other open seat, the closest person has distance 1.Thus, the maximum distance to the closest person is 2.Example 2:Input: [1,0,0,0]Output: 3Explanation: If Alex sits in the last seat, the closest person is 3 seats away.This is the maximum distance possible, so the answer is 3.Note:1 &lt;= seats.length &lt;= 20000seats contains only 0s or 1s, at least one 0, and at least one 1.if close end, both ends bound with 1, e.g. 100001, the intermediate result is (zero count+1)/2if open end, either one end unbound, e.g. 1000 or 0001, the intermediate result is the &apos;zero count&apos;find the max agmost intermediate results*/func maxDistToClosest(seats []int) int &#123; zeroCnt := 0 openEnd := false max := 0 for i, seat := range seats&#123; if seat == 0&#123; zeroCnt++ if i == 0 || i == len(seats) - 1&#123; openEnd = true &#125; &#125; else&#123; if openEnd&#123; if zeroCnt &gt; max&#123; max = zeroCnt &#125; &#125; else&#123; tmp := (zeroCnt+1)/2 if tmp &gt; max&#123; max = tmp &#125; &#125; zeroCnt = 0 openEnd = false &#125; &#125; if openEnd &#123; if zeroCnt &gt; max &#123; max = zeroCnt &#125; &#125; else &#123; temp := (zeroCnt + 1) / 2 if temp &gt; max &#123; max = temp &#125; &#125; return max&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式事务]]></title>
    <url>%2F2020%2F02%2F21%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%88%86%E5%B8%83%E5%BC%8F%2F%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[分布式事务分布式事务指事务的操作位于不同的节点上，需要保证事务的ACID特性。* 2PC * TCC * 本地消息表 * MQ事务消息2PC两阶段提交（Two-phase Commit，2PC）是基于分布式架构下的所有节点在进行事务提交时保持一致性而设计的一种算法。在分布式系统中，每个节点虽然可以知晓自己的操作成功或者失败，却无法知道其他节点的操作成功或失败。 当一个节点跨域多个节点时，为了保证事务的 ACID 特性，需要引入一个协调者（Coordinator）来统一掌握所有节点（参与者）的操作结果并最终指示这些节点是否要把操作结果真正提交。 思路参与者将操作成败通知协调者，再由协调者根据所有参与者反馈情况决定各参与者是否提交操作还是终止操作。 2个阶段 阶段1：请求阶段（commit-request phase）/ 表决阶段（voting phase） 协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。 参与者节点执行询问发起为止的所有事务操作 各参与者节点响应协调者发起的询问 阶段2：提交阶段（commit phase） 如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。 需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。 存在的问题 同步阻塞 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。 单点问题 协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待，无法完成其它操作。 数据不一致 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。 太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。 TCCTCC 即补偿事务，其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段： * Try 阶段主要是对业务系统做检测及资源预留； * Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功； * Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。 举个例子，假入 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用 首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。 在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。 如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。优点跟 2PC 比起来，实现以及流程相对简单了一些，但数据的一致性比 2PC 也要差一些 缺点缺点还是比较明显的，在2,3步中都有可能失败。TCC 属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用 TCC 不太好定义及处理。 本地消息表此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。 本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。 * 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。 * 之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。 * 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。 * 如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作这种方案遵循 BASE 理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像 2PC 那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。 优点一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。 缺点消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。 MQ 事务消息有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。 以阿里的 RocketMQ 中间件为例，其思路大致为： 第一阶段Prepared消息，会拿到消息的地址。 第二阶段执行本地事务。 第三阶段通过第一阶段拿到的地址去访问消息，消息接受者就能使用这个消息。 也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。 优点实现了最终一致性，不需要依赖本地数据库事务。 缺点实现难度大，主流 MQ 不支持，RocketMQ 事务消息部分代码也未开源。]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find Pivot Index(724)]]></title>
    <url>%2F2020%2F02%2F21%2FFind-Pivot-Index-724%2F</url>
    <content type="text"><![CDATA[Find Pivot Index(724)1234567/*Given an array of integers nums, write a method that returns the &quot;pivot&quot; index of this array.We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.Example 1: 123456789101112131415161718192021222324252627282930313233Input: nums = [1, 7, 3, 6, 5, 6]Output: 3Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.Also, 3 is the first index where this occurs.Example 2:Input: nums = [1, 2, 3]Output: -1Explanation: There is no index that satisfies the conditions in the problem statement.*/func pivotIndex(nums []int) int &#123; lsum, rsum := 0, sum(&amp;nums) for i := 0; i &lt; len(nums); i++&#123; rsum -= nums[i] if rsum == lsum&#123; return i &#125; lsum += nums[i] &#125; return -1&#125;func sum(nums *[]int) int&#123; sum := 0 for _, n := range *nums&#123; sum += n &#125; return sum&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maximum Product of Three Numbers(628)]]></title>
    <url>%2F2020%2F02%2F20%2FMaximum-Product-of-Three-Numbers-628%2F</url>
    <content type="text"><![CDATA[Maximum Product of Three Numbers(628)123456789101112131415/*Give an integer array, find three numbers whose produce is maximum and output the maximum produce.Example 1:Input: [1,2,3]Output: 6Example 2:Input: [1,2,3,4]Output: 24Note:The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000].Multiplication of any three numbers in the input won&apos;t exceed the range of 32-bit signed integer*/ 123456789101112131415161718func maximumProduce(nums []int) int&#123; max1, max2, max3, min1, min2 := math.MinInt32, math.MinInt32, math.MinInt32, math.MaxInt32, math.MaxInt32 for _, num := range nums &#123; if num &gt; max1 &#123; max1, max2, max3 = num, max1, max2 &#125; else if num &gt; max2 &#123; max2, max3 = num, max2 &#125; else if num &gt; max3 &#123; max3 = num &#125; if num &lt; min1 &#123; min1, min2 = num, min1 &#125; else if num &lt; min2 &#123; min2 = num &#125; &#125; return int(math.Max(float64(max1*max2*max3), float64(max1*min1*min2)))&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式锁]]></title>
    <url>%2F2020%2F02%2F19%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%88%86%E5%B8%83%E5%BC%8F%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[分布式锁在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。* 数据库的唯一索引 * Redis的SENTX指令 * Redis的RedLock算法 * 基于Zookeeper实现分布式锁数据库的唯一索引获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否存于锁定状态。 存在以下几个问题： * 锁没有失效时间，解锁失败的话其它进程无法再获得该锁。 * 只能是非阻塞锁，插入失败直接就报错了，无法重试。 * 不可重入，已经获得锁的进程也必须重新获取锁。Redis 的 SETNX 指令使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。 SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。 EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。 Redis 的 RedLock 算法使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。 * 尝试从 N 个相互独立 Redis 实例获取锁； * 计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，那么就认为锁获取成功了； * 如果锁获取失败，就到每个实例上释放锁。基于 Zookeeper 实现分布式锁为了保证高可用，Zookeeper 需要以集群形态来部署，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 Zookeeper 本身仍然是可用的。 客户端在使用 Zookeeper 时，需要知道集群机器列表，通过与集群中的某一台机器建立 TCP 连接来使用服务，客户端使用这个 TCP 连接来发送请求、获取结果、获取监听事件以及发送心跳。如果这个连接断开了，客户端可以连接到另外的机器上。 客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 Zookeeper 机器来处理。写请求会同时发给其他 Zookeeper 机器并且达成一致后，请求才会成功。 因此，随着 Zookeeper 的集群机器增多，读请求的吞吐量会提高，但写请求的吞吐量会下降。 Zookeeper 抽象模型Zookeeper 提供了一种树形结构级的命名空间，/app1/p_1 节点的父节点为 /app1。 节点类型* 永久节点：不会因为会话结束或者超时而消失； * 临时节点：如果会话结束或者超时就会消失； * 有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。监听器为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。当前 Zookeeper 有如下 4 种事件： * 节点创建 * 节点删除 * 节点数据修改 * 子节点变更分布式锁实现* 创建一个锁目录 /lock； * 当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点； * 客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则 **监听 /lock 子节点** ，获得子节点的变更通知后重复此步骤直至获得锁； * 执行业务代码，完成后，删除对应的子节点。会话超时如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，Zookeeper 分布式锁不会出现数据库的唯一索引实现的分布式锁释放锁失败问题。 羊群效应一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应），而我们只希望它的后一个子节点收到通知。 调整后的分布式锁实现* 创建一个锁目录 /lock； * 当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点； * 客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则 **监听自己的前一个子节点**，获得子节点的变更通知后重复此步骤直至获得锁； * 执行业务代码，完成后，删除对应的子节点。]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pascal's Triangle II(119)]]></title>
    <url>%2F2020%2F02%2F19%2FPascal-s-Triangle-II-119%2F</url>
    <content type="text"><![CDATA[### 12345678910111213141516171819202122/*Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal&apos;s triangle.Note that the row index starts from 0.Example:Input: 3Output: [1,3,3,1]*/func getRow(rowIndex int) []int&#123; // from 0 rowIndex = rowIndex + 1 result := make([]int, rowIndex) for i := 0; i &lt; rowIndex; i++&#123; if i == 0&#123; result[i] = 1 &#125; else&#123; for j := rowIndex - 1; j &gt; 0; j--&#123; result[j] += result[j-1] &#125; &#125; &#125; return result&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min Cost Climbing Stairs(746)]]></title>
    <url>%2F2020%2F02%2F18%2FMin-Cost-Climbing-Stairs-746%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223/*On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.*/func minCostClimbingStairs(cost []int) int &#123; dp := make([]int, len(cost)) dp[0], dp[1] = cost[0], cost[1] for i := 2; i &lt; len(cost); i++&#123; dp[i] = min(dp[i-1], dp[i-2]) + cost[i] &#125; return min(dp[len(cost)-1], dp[len(cost)-2])&#125;func min(a, b int) int&#123; if a &lt; b&#123; return b &#125; else&#123; return b &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BASE理论]]></title>
    <url>%2F2020%2F02%2F17%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%88%86%E5%B8%83%E5%BC%8F%2FBASE%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[BASE理论在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢？ 前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。 BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 基本可用指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。 例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。 软状态指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。 最终一致性最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。 ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。 在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAP理论]]></title>
    <url>%2F2020%2F02%2F17%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%88%86%E5%B8%83%E5%BC%8F%2FCAP%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[概念分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。一致性（Consistency)一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。 对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。 可用性（Availability）可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。 在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果，正常或异常反馈结果。主要体现在反馈即可。 分区容忍性（Partition Tolerance）网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。 在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。 权衡在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性（A）和一致性（C）之间做权衡。 可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时， * 为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性，zookeeper其实就是追求的强一致； * 为了保证可用性（AP），放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，BASE理论也是根据AP来扩展。]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式系统设计理念]]></title>
    <url>%2F2020%2F02%2F17%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%88%86%E5%B8%83%E5%BC%8F%2F%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[目标分布式系统的目标是提升系统的整体性能和吞吐量另外还要尽量保证分布式系统的容错性。设计思路1.中心化 2种角色 分布式集群中的节点机器按照角色分工，大体上分为两种角色：“领导”和“员工”。 角色职责 “领导”通常负责分发任务并监督“员工”，发现谁太闲了，就想发设法地给其安排新任务，确保没有一个“干活的”能够偷懒，如果“领导”发现某个“干活的”因为劳累过度而病倒了，则是不会考虑先尝试“医治”他的，而是一脚踢出去，然后把他的任务分给其他人。 面临的问题 最大问题是“领导”的安危问题，如果“领导”出了问题，则群龙无首。 2.去中心化 地位平等 “去中心化”不是不要中心，而是由节点来自由选择中心 集群的成员会自发的举行“会议”选举新的“领导”主持工作。 面临的问题 脑裂问题。脑裂指一个集群由于网络的故障，被分为至少两个彼此无法通信的单独集群，此时如果两个集群都各自工作，则可能会产生严重的数据冲突和错误。 一般的设计思路是，当集群判断发生了脑裂问题时，规模较小的集群就“自杀”或者拒绝服务。 分布式与集群 分布式 一个业务拆分为多个子业务，部署在不同服务器上 集群 同一业务，部署在多个服务器上]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock(121)]]></title>
    <url>%2F2020%2F02%2F17%2FBest-Time-to-Buy-and-Sell-Stock-121%2F</url>
    <content type="text"><![CDATA[### 123456789101112/*Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.Not 7-1 = 6, as selling price needs to be larger than buying price.Example 2:Input: [7,6,4,3,1]Output: 0Explanation: In this case, no transaction is done, i.e. max profit = 0.*/ 123456789101112131415161718func maxProfit(prices []int) int &#123; if len(prices) == 0 || len(prices) == 1&#123; return 0 &#125; max := 0 for i := 0; i &lt; len(prices); i++&#123; lowPriceIndex, highPriceIndex := i, i for j := i + 1; j &lt; len(prices); j++&#123; if prices[j] &gt; prices[highPriceIndex]&#123; highPriceIndex = j &#125; &#125; if(lowPriceIndex &lt; highPriceIndex) &amp;&amp; (max &lt; prices[highPriceIndex] - prices[lowPriceIndex])&#123; max = prices[highPriceIndex] - prices[lowPriceIndex] &#125; &#125; return max&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中涉及到的设计模式]]></title>
    <url>%2F2020%2F02%2F16%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%2FSpring%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式BeanFactory 用来创建各种不同的 Bean。代理模式AOP、事务都大量运用了代理模式。单例模式在 Spring 配置文件中定义的 Bean 默认为单利模式。原型模式特点在于通过”复制”一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们所称的”原型”，这个原型是可定制的。 责任链模式在 SpringMVC 中，会经常使用一些拦截器(HandlerInterceptor)，当存在多个拦截器的时候，所有的拦截器就构成了一条拦截器链。 观察者模式Spring 中提供了一种监听机制，即 ApplicationListenber，可以实现 Spring 容器内的事件监听。]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>常用框架</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC]]></title>
    <url>%2F2020%2F02%2F16%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%2FSpringMVC%2F</url>
    <content type="text"><![CDATA[MVC即 Model-View-Controller，是一种复合模式。* Model：模型。封装数据源和所有基于这些数据的操作 * View：视图。用来显现模型 * Controller：控制器。封装外界作用于模型的操作其中，模型利用 “观察者模式” 让 Controller 和视图随最新的状态改变而更新；View 和 Controller 实现 “策略模式”，控制器是视图的行为，若希望有不同的行为，可直接换一个控制器；视图内部利用“组合模式”。 优点： * 三个模块可共享一个模型，大大提高代码的可重用性 * 三个模块相互独立，耦合性较低 * Controller 提高了应用程序的灵活性，使用 Controller 可连接不同模型和视图去满足用户的需求SpringMVCSpringMVC 是一种基于 Java，实现了 Web MVC 设计模式，请求驱动类型的轻量级 Web 框架。优点如下： * 基于组件技术。全部的应用对象，无论是控制器、视图，还是业务对象之类都是 Java 组件。并且和 Spring 提供的其他基础结构紧密集成； * 不依赖于 Servlert API； * 可以任意使用各种视图技术，而不仅仅局限于jspl； * 支持各种请求资源的映射策略； * 易扩展。原理SpringMVC 框架是以请求为驱动，围绕 Servlet 设计，将请求发给控制器，然后通过模型对象，分派器来展示请求结果视图。 其中核心类是 DispatcherServlet，它是一个 Servlet，顶层实现 Servlet 接口。 组件DispatcherServlet 说明：前端控制器，不需要工程师开发，由 SpringMVC 框架提供。 作用：Spring MVC 的入口。接收请求，响应结果，相当于转发器，中央处理器。DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 降低了组件之间的耦合度。 HandlerMapping 说明：处理器映射器，不需要工程师开发，由 SpringMVC 框架提供。 作用：根据请求的 url 查找 Handler。SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlerAdapter 说明：处理器适配器。 作用：按照特定规则（HandlerAdapter要求的规则）执行 Handler。通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 Handler 说明：处理器，需要工程师开发。 注意：编写 Handler 时按照 HandlerAdapter 的要求的规则去做，这样适配器才可以去正确执行 Handler, Handler 是后端控制器，在 DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理。 由于 Handler 涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发 Handler。 ViewResolver 说明：视图解析器，不需要工程师开发，由 SpringMVC 框架提供。 作用：进行视图解析，根据逻辑视图名解析成真正的视图。ViewResolver 负责将处理结果生成 View 视图， ViewResolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成 View 视图对象，最后对View 进行渲染将处理结果通过页面展示给用户。 SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要工程师根据业务需求开发具体的页面。 View 说明：视图 View，需要工程师开发。 作用：View 是一个接口，实现类支持不同的 View类型（jsp、freemarker、pdf…）。]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>常用框架</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中常见注解]]></title>
    <url>%2F2020%2F02%2F16%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%2FSpring%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@Configuration* 表示一个配置文件（配置源） * 当配置类@Configuration之后，配置类内部方法之间发生依赖关系，能够保证单例，保证从容器中获取，原因是将该类转变成代理类去执行123456789101112@configurationpublic class AppConfig&#123; @Bean public User user()&#123; return new User() &#125; @Bean public UserService userService()&#123; return new UserService(user()) &#125;&#125; @ContollerSpringMVC 中，控制器 Controller 负责处理 DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个 Model，然后再把该 Model 返回给对应的 View 进行展示。 SpringMVC 提供了一个非常简便的定义 Controller 的方法，你无需继承特定的类或者接口，只需使用 @Controller 标记一个类是 Contoller。 @RequestMapping使用 @RequestMapping 来映射 URL 到控制器，或者到 Controller 控制器的处理方法上。method 的值一旦指定，则处理方法只对指定的 HTTP method 类型请求处理。 可以为多个方法映射相同的 URI，不同的 HTTP method 类型，Spring MVC 根据请求的 method 类型是可以区分开这些方法的。 @RequestParam 和 @PathVariable在 SpringMVC 中，两者的作用都是将 request 里的参数的值绑定到 Controller 里的方法参数中，区别在于 URL 的写法不同。 * 使用 @RequestParam 时，URL 是这样的： http://host:port/path?参数名=参数值 * 使用 @PathVariable 时，URL 是这样的： http://host:port/path/参数值@Autowired@Autowired 可以对成员变量、成员方法和构造函数进行标注，来完成自动装配工作。 @Service、 @Contrller、 @Repository 和 @Component@Service、 @Contrller、 @Repository 其实这 3 个注解和 @Component 是等效的，用在实现类上： * @Service 用于标注业务层组件 * @Controller 用于标注控制层组件 * @Repository 用于编著数据访问组件 * @Component 泛指组件，当组件不好归类时，可以使用这个注解进行标注@Value在 Spring 3.0 中，可以通过使用 @Value，对一些如 xxx.properties 文件中的文件，进行键值对的注入。 @ResponseBody该注解用于将 Controller 中方法返回的对象，通过适当的 HttpMessageConverter 转换为指定的格式后，写入到 Response 对象的 bodys 数据区。 @Autowired 和 @Resource 的区别@Autowired * Spring 提供的注解 * 采用的策略是按照类型注入的1234567891011public class UserService&#123; @Autowired userDao; //在 Spring 容器中找到类型为 userDao 的类，将其注入&#125;//存在问题：同一类型有多个 Bean，可以使用 @Qualifier 具体去装配哪个对象。public class UserService&#123; @Autowired @Qualifier(name=&quot;userDao&quot;) userDao; //在 Spring 容器中找到类型为 userDao 的类，将其注入&#125; @Resource * J2EE 提供的注解 * 默认是按照名称注入的12345678910111213Service&#123; @Resource userDao; //自动按名称进行装配 @Resource(name=&quot;studentDao&quot;) studentDao; //按名称进行装配，找不到会抛出异常 @Resource(type=&quot;TeacherDao&quot;) teacherDao; //按类型进行装配，找不到或者找到多个都会抛出异常 @Resource(name=&quot;manDao&quot;,type=&quot;ManDao&quot;) manDao;//找唯一匹配的 Bean 进行装配，如果找不到则会抛出异常&#125;]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>常用框架</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中Bean的作用域与生命周期]]></title>
    <url>%2F2020%2F02%2F15%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%2FSpring%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[作用域类型Spring Framework 支持五种作用域： 类型 描述 singleton 在 SpringIoC 容器中仅存在一个 Bean 实例，Bean 以单例方式存在 prototype 每次从容器中调用 Bean 时，都返回一个新的实例 request 每次HTTP请求都会创建一个新的 Bean,该作用域仅适用于 WebApplicationContext 环境 session 同一个 Http Session 共享一个 Bean,不同 Session 使用不同 Bean,仅适用于WebApplicationContext 环境 globalSession 一般同于 Portlet 应用环境，该作用域仅适用于 WebApplicationContext 环境 注意：五种作用域中，request、session 和 global session 三种作用域仅在基于 web 的应用中使用(不必关心你所采用的是什么web应用框架)，只能用在基于 web 的 Spring ApplicationContext 环境。 singleton当一个 Bean 的作用域为 singleton，那么Spring IoC容器中只会存在一个共享的 Bean 实例， 并且所有对 Bean 的请求，只要 id 与该 Bean 定义相匹配，则只会返回 Bean 的同一实例。 singleton 是单例类型(对应于单例模式)，就是在创建容器时就同时自动创建一个Bean对象， 不管你是否使用，但我们可以指定Bean节点的 lazy-init=”true” 来延迟初始化Bean， 这时候，只有在第一次获取Bean时才会初始化Bean，即第一次请求该bean时才初始化。 每次获取到的对象都是同一个对象。 注意，singleton 作用域是Spring中的缺省作用域。 * 配置文件XML中将 Bean 定义成 singleton ： &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.southeast.service.ServiceImpl&quot; scope=&quot;singleton&quot;&gt; * @Scope 注解的方式： @Service @Scope(&quot;singleton&quot;) public class ServiceImpl{ }prototype当一个Bean的作用域为 prototype，表示一个 Bean 定义对应多个对象实例。 prototype 作用域的 Bean 会导致在每次对该 Bean 请求 (将其注入到另一个 Bean 中，或者以程序的方式调用容器的 getBean() 方法)时都会创建一个新的 bean 实例。 prototype 是原型类型，它在我们创建容器的时候并没有实例化， 而是当我们获取Bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。 根据经验，对有状态的 Bean 应该使用 prototype 作用域，而对无状态的 Bean 则应该使用 singleton 作用域。 * 配置文件XML中将 Bean 定义成 prototype ： &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.southeast.service.ServiceImpl&quot; scope=&quot;prototype&quot;&gt; 或者 &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.southeast.service.ServiceImpl&quot; singleton=&quot;false&quot;/&gt; * @Scope 注解的方式： @Service @Scope(&quot;prototype&quot;) public class ServiceImpl{ }Spring 中线程安全问题，有状态 Bean 和 无状态 Bean： * 有状态 Bean 对象中有实例变量（成员变量），可保存数据； 非线程安全。 * 无状态 Bean 对象中无实例变量，不能保存数据，可在多线程环境下共享； 线程安全。Spring 中有状态 Bean 如何保证线程安全？ 2 种方式保证线程安全： * 采用 ThreadLocal 进行处理 * 采用原型模式，每次有 Bean 请求时，都会创建一个新的 Bean 实例requestrequest只适用于Web程序，每一次 HTTP 请求都会产生一个新的 Bean ， 同时该 Bean 仅在当前HTTP request内有效，当请求结束后，该对象的生命周期即告结束。 在 XML 中将 bean 定义成 request ，可以这样配置： * 配置文件XML中将 Bean 定义成 prototype ： &lt;bean id=&quot;ServiceImpl&quot; class=&quot;com.southeast.service.ServiceImpl&quot; scope=&quot;request&quot;&gt;sessionsession只适用于Web程序， session 作用域表示该针对每一次 HTTP 请求都会产生一个新的 Bean， 同时该 Bean 仅在当前 HTTP session 内有效。 与request作用域一样，可以根据需要放心的更改所创建实例的内部状态， 而别的 HTTP session 中根据 userPreferences 创建的实例， 将不会看到这些特定于某个 HTTP session 的状态变化。 当HTTP session最终被废弃的时候，在该HTTP session作用域内的bean也会被废弃掉。 &lt;bean id=&quot;userPreferences&quot; class=&quot;com.foo.UserPreferences&quot; scope=&quot;session&quot;/&gt;globalSessionglobalSession 作用域类似于标准的 HTTP session 作用域， 不过仅仅在基于 portlet 的 Web 应用中才有意义。 Portlet 规范定义了全局 Session 的概念， 它被所有构成某个 portlet web 应用的各种不同的 portlet所共享。 在globalSession 作用域中定义的 bean 被限定于全局portlet Session的生命周期范围内。 &lt;bean id=&quot;user&quot; class=&quot;com.foo.Preferences &quot;scope=&quot;globalSession&quot;/&gt;Spring中Bean的生命周期Bean 的创建过程 1、Spring 对 Bean 进行实例化。 2、Spring 将值和 Bean 的引用注入到 Bean 对应的属性中。 3、如果 Bean 实现了 BeanNameAware 接口，Spring 将 bean 的 id 传递给 setBeanName() 接口方法。 4、如果 Bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory() 接口方法，将 BeanFactory 容器实例传入。 5、如果 Bean 实现了 ApplicationContextAware 接口，Spring 将调用 setApplicationContext() 接口方法，将应用上下文的引用传入。 6、如果 Bean 实现了BeanPostProcessor 接口，Spring 将调用 postProcessBeforeInitialization() 接口方法。 7、如果 Bean 实现了InitializingBean 接口，Spring 将调用他们的 afterPropertiesSet() 接口方法 8、如果Bean 实现了 init-method 声明了初始化方法，该方法也会被调用。 9、如果 Bean 实现了BeanPostProcessor 接口，Spring 将调用 postProcessAfterInitialization() 接口方法。 10、此时 Bean 已经准备就绪，可以被应用程序使用了，他们将一一直驻留在应用上下文中，一直到该应用上下文被销毁。 11、如果 Bean 实现了 DisposableBean 接口，Spring 将调用它的 destroy() 接口方法。 12、如果 Bean 使用 destroy-method 声明了销毁方法，方法也会被调用。]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>常用框架</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 事务]]></title>
    <url>%2F2020%2F02%2F15%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%2FSpring-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[编程式事务和声明式事务编程式事务：指的是通过编码方式实现事务，类似JDBC编程实现事务管理，比如jdbcTemplate、TransactionalTemplate。声明式事务：1）XML实现 2）@Transactional 注解实现 事务方式 优点 缺点 编程式事务 显示调用，不易出错 侵入式代码，编码量大 声明式事务 简洁，对代码侵入少 隐藏实现细节，出错不易定位 Spring事务管理Spring 事务的本质是基于数据库对事务的支持，没有数据库对事务的支持，Spring 本身无法提供事务管理功能。Spring 事务通过 AOP 动态代理来是实现。通常先在配置文件中开启事务，然后通过 xml 文件或者注解配置执行方法，在调用方法时，Spring 会自动生成代理，在调用前设置事务操作，调用方法后进行事务回滚或者提交操作。 Spring 中事务隔离级别 隔离级别 说明 ISOLATION_DEFAULT（默认) 这是默认值，表示使用底层数据库的默认隔离级别。 ISOLATION_READ_UNCOMMITTED（读未提交) 该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据，该级别不能防止脏读和不可重复读，因此很少使用该隔离级别 ISOLATION_READ_COMMITTED（读可提交） 该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值 ISOLATION_REPEATABLE_READ（可重复读） 该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。即使在多次查询之间有新增的数据满足该查询，这些新增的记录也会被忽略。该级别可以防止脏读和不可重复读 ISOLATION_SERIALIZABLE（可串行化） 所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是，这将严重影响程序的性能，通常情况下也不会用到该级别 Spring 七种事务传播类型* PROPAGATION_REQUIRED（required） 如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务。 * PROPAGATION_SUPPORTS（support） 表示支持当前事务，如果当前没有事务，就以无事务方式执行。 * PROPAGATION_MANDATORY（mandatory） 表示使用当前的事务，如果当前没有事务，就抛出异常。 * PROPAGATION_REQUIRES_NEW（required_new） 表示新建事务，如果当前存在事务，把当前事务挂起。 * PROPAGATION_NOT_SUPPORTED（not_support） 表示以无事务方式执行操作，如果当前存在事务，就把当前事务挂起。 * PROPAGATION_NEVER（never） 表示以无事务方式执行，如果当前存在事务，则抛出异常。 * PROPAGATION_NESTED（nested） 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。12345678910111213141516171819202122232425262728StudentServiceImplA implements StudentService&#123; @Autowired studentDao; @Autowired studentService; @Transactional(required) //事务传播特性为 requried insertA()&#123; //...对数据库操作，插入 A 数据 studentService.insertB();// 插入 B 数据 //..i/o 异常 &#125;&#125;StudentServiceImplB implements StudentService&#123; @Autowired studentDao; @Transactional insertB()&#123; //...对数据库操作，插入 B 数据 &#125;&#125; StudentServiceImplB 中 insertB() 中传播类型如果是 required，数据库中既没有 A 数据，也没有 B 数据； （insertA() 和 insertB() 属于同一个事务，发生异常，事务回滚） StudentServiceImplB 中 insertB() 中传播类型如果是 required_new，数据库中没有 A 数据，但是有 B 数据； （insertB() 创建了一个新事务，insertA() 中发生异常，事务回滚） StudentServiceImplB 中 insertB() 中传播类型如果是 not_supported，数据库中没有 A 数据，但是有 B 数据 （insertB() 以非事务方式执行，执行 insertA() 的事务回滚，insertB()中不会发生回滚） 注意：insertB() 为何要放入 StudentServiceImplB 中？ Spring 的事务机制是使用 AOP 代理实现的。 如果在 StudentServiceImplA 中使用 insertB() ，insertA() 中在调用 insertB() 是通过当前对象来调用 doB() 的，而不是通过代理来调用 doB() 的，此时 doB() 上加事务注解就失效了。]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>常用框架</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP]]></title>
    <url>%2F2020%2F02%2F15%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%2FSpring-AOP%2F</url>
    <content type="text"><![CDATA[AOP能做什么面向切面编程（Aspect Oriented Programing）。实际上是将一些通用的功能横向抽取出来：一方面，可减少系统的代码；另一方面，降低模块间的耦合度，比较好的维护和扩展。* 性能监控，在方法调用前后记录调用时间，方法执行太长或超时报警。 * 缓存代理，缓存某方法的返回值，下次执行该方法时，直接从缓存里获取。 * 软件破解，使用AOP修改软件的验证类的判断逻辑。 * 记录日志，在方法执行前后记录系统日志。 * 工作流系统，工作流系统需要将业务代码和流程引擎代码混合在一起执行，那么我们可以使用AOP将其分离，并动态挂接业务。 * 权限验证，方法执行前验证是否有权限执行当前方法，没有则抛出没有权限执行异常，由业务代码捕捉。 静态代理1234// 公共接口interface DO&#123; public abstract void doSomething();&#125; 123456// 真实对象类class RealObject implements DO&#123; public void doSomething()&#123; System.out.print(&quot;hello,我是真实对象...&quot;); &#125;&#125; 1234567891011121314151617// 代理对象类class ProxyObject implements DO&#123; private RealObject realObj = null;//真实对象的引用 public ProxyObject()&#123; realObj = new RealObject(); &#125; public void doSomething() &#123; //1、做一些权限控制之类的 if(realObj==null)&#123;//2、延迟加载 realObj = new RealObject(); &#125; realObj.doSomething(); //3、再做一些事情 &#125; &#125; 123// 测试代码ProxyObject proxyObj = new ProxyObject();proxyObj.doSomething(); 动态代理github参考:https://github.com/MatrixSeven/JavaAOP 1234// 公共接口interface DO&#123; public abstract void doSomething();&#125; 123456// 真实对象类class RealObject implements DO&#123; public void doSomething()&#123; System.out.print(&quot;hello,我是真实对象...&quot;); &#125;&#125; 123456789101112131415161718192021// 实现java提供的java.lang.reflect.InvocationHandler接口public class MyInvocationHandler implements InvocationHandler&#123; //真实对象引用 private Object realObj=null; public MyInvocationHandler(Object realObj)&#123; this.realObj = realObj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args)throws Throwable &#123; //。。。在真实对象执行方法前做一些处理 method.invoke(realObj, args); //。。在真实对象执行方法之后做些处理 return null; &#125; //获取真实对象的代理对象 public Object getProxy() &#123; return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),realObj.getClass().getInterfaces(), this); &#125; &#125; 123456789// 测试//真实对象RealObject realObj = new RealObject();//调用处理器MyInvocationHandler handler = new MyInvocationHandler(realObj);//生成代理对象Do proxyObj = (Do)handler.getProxy();//代理执行方法proxyObj.doSomething(); Spring AOP原理 * JDK 动态代理 * Cglib 动态代理概念 术语 描述 Joinpoint(连接点) 所谓连接点是指那些被拦截到的点。在Spring中,这些点指的是方法,因为Spring只支持方法类型的连接点。 Pointcut(切入点) 所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。 Advice(通知/增强) 所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能) Introduction(引介) 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field Target(目标对象) 代理的目标对象 Weaving(织入) 指把增强应用到目标对象来创建新的代理对象的过程。 有三种织入方式： Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 Proxy（代理) 一个类被AOP织入增强后，就产生一个结果代理类 Aspect(切面) 是切入点和通知（/引介）的结合 Spring的通知 * @Before 前置：方法执行前切入。 * @AfterReturning 后置正常：方法正常执行后切入。 * @AfterThrowing 异常：抛出异常后切入。 * @After 后置：方法无论成功与否，退出后切入。 * @Around 环绕：在方法执行前执行后切入。1234567891011121314// Spring配置文件&lt;beans //省略 xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;//省略 http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!-- aspect注解生效--&gt; &lt;!-- &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt; --&gt;&lt;/beans&gt;//注：&lt;aop:aspectj-autoproxy/&gt;有一个默认属性proxy-target-class，默认为false,表示使用JDK动态代理实现织入。//若proxy-target-class=&quot;true&quot;表示使用CGLib技术织入增强。//当然我们知道JDK动态代理是基于接口的，如果目标类不存在接口，Spring将自动使用CGLib实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!-- Spring AOP --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.3.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;/dependency&gt; 123456789101112131415161718192021222324252627282930@Component@Aspectpublic class LogAspect &#123; @Pointcut(&quot;execution(* com.danlu.aoptest.service.*.*(..)) &quot;) private void logMethod()&#123;&#125; @Around(&quot;logMethod()&quot;) public Object logAround(ProceedingJoinPoint point)&#123; String methodName = null; //方法名 Object[] params = null; //入參 Object returnValue = null; //返回值 long execTime = 0; //执行时间 try &#123; methodName = &quot;[&quot; + point.getSignature().getDeclaringTypeName() + &quot;.&quot; + point.getSignature().getName() + &quot;]&quot;; System.out.println(&quot;目标方法为：&quot; + methodName); params = point.getArgs(); Gson gson = new Gson(); System.out.println(&quot;参数为:&quot; + gson.toJson(params)); long startTime = System.currentTimeMillis(); returnValue = point.proceed(params); System.out.println(&quot;返回值为：&quot; + gson.toJson(returnValue)); execTime = System.currentTimeMillis()-startTime; System.out.println(&quot;执行时间为：&quot; + execTime + &quot;ms&quot;); &#125; catch (Throwable e) &#123; System.out.println(methodName + &quot;调用失败，抛出异常：&quot;+ e); &#125; return returnValue; &#125;&#125; 控制层演示实例1234567891011121314151617181920212223242526@Controllerpublic class AOPTestController &#123; @Resource private AopTestService aopTestService; @ResponseBody @RequestMapping(&quot;getPersonInfo&quot;) public Map&lt;String,Object&gt; getPersonInfo(int age)&#123; Map&lt;String,Object&gt; result = new HashMap&lt;String,Object&gt;(); Person p0 = new Person(); p0.setName(&quot;小强&quot;); p0.setSex(&quot;男&quot;); p0.setAge(age); try &#123; long startTime = System.currentTimeMillis(); Person p = this.aopTestService.getPersonInfo(&quot;小强&quot;,&quot;男&quot;,age,p0); System.out.println(&quot;controller调用目标方法的执行时间为：&quot; + (System.currentTimeMillis()-startTime) + &quot;ms&quot;); result.put(&quot;success&quot;, true); result.put(&quot;p&quot;, p); &#125; catch (Exception e) &#123; &#125; return result; &#125;&#125; 12345678910111213141516// 业务层演示实例@Servicepublic class AopTestServiceImpl implements AopTestService&#123; @Override public Person getPersonInfo(String name,String sex,int age,Person p0) throws Exception &#123; if(age &lt; 1)&#123; throw new IllegalArgumentException(); &#125; Person p = new Person(); p.setName(&quot;小强&quot;); p.setSex(&quot;男&quot;); p.setAge(age); return p; &#125;&#125; 1234567891011121314访问http://localhost:8080/aopTest/getPersonInfo.do?age=1目标方法为：[com.danlu.aoptest.serviceImpl.AopTestServiceImpl.getPersonInfo]参数为:[&quot;小强&quot;,&quot;男&quot;,1,&#123;&quot;name&quot;:&quot;小强&quot;,&quot;age&quot;:1,&quot;sex&quot;:&quot;男&quot;&#125;]返回值为：&#123;&quot;name&quot;:&quot;小强&quot;,&quot;age&quot;:1,&quot;sex&quot;:&quot;男&quot;&#125;执行时间：15mscontroller调用目标方法的执行时间为：64ms访问http://localhost:8080/aopTest/getPersonInfo.do?age=0目标方法为：[com.danlu.aoptest.serviceImpl.AopTestServiceImpl.getPersonInfo]参数为:[&quot;小强&quot;,&quot;男&quot;,0,&#123;&quot;name&quot;:&quot;小强&quot;,&quot;age&quot;:0,&quot;sex&quot;:&quot;男&quot;&#125;][com.danlu.aoptest.serviceImpl.AopTestServiceImpl.getPersonInfo]调用失败，抛出异常：java.lang.IllegalArgumentExceptioncontroller调用目标方法的执行时间为：2ms 动态代理、CGLib等形式的AOP实现，本质上还是代理，无论是基于接口的JDK动态代理，还是基于类的CGLib,都要为目标类生成代理类，这是否要考虑类膨胀的问题，是否有必要加大JVM方法区大小，这都是需要实践和测试的。]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>常用框架</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC]]></title>
    <url>%2F2020%2F02%2F11%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1_%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%2FSpring-IOC%2F</url>
    <content type="text"><![CDATA[IOC 概念IOC，即控制反转（Iversion of Control）是一种设计思想* 控制：控制对象的创建及销毁(生命周期)。 * 反转：将对象的控制权交给 IoC 容器。使用 IOC 的好处：* 避免在各处使用 new 来创建类，并且可以统一维护 * 创建实例时，不需要了解其中的细节所有的类都会在Spring容器中注册，告诉Spring你是什么类，你需要什么类，然后Spring会在系统运行的时候把你需要的类信息主动给你。所有类的创建、销毁都有Spring来控制，也就是说控制对象生命周期的不是引用它的对象，而是Spring。对某个具体对象而言，以前它是控制其他对象，现在所有对象都被Spring控制 依赖注入(Dependency Injection,DI)所谓依赖注入就是底层类作为参数传递给上层类，实现上层对下层的控制，依赖注入实现控制反转举例：汽车生产 * 传统方式： 生产 轮子 -&gt; 底盘 -&gt; 车外壳 -&gt; 汽车 * Spring： 生产 汽车 -&gt; 车外壳 -&gt; 底盘 -&gt; 轮子IOC 和 DI 的关系使用DI实现IOC DI的实现方式： * setter注入 * 构造器注入 * 接口注入 * 注解注入依赖倒置原则、IOC、DI、IOC容器的关系 IOC 容器的初始化过程XML(读取) -&gt; Resource(解析) -&gt; BeanDefinition(注册) -&gt; BeanFactory * Resource定位(即BeanDefinition的资源定位，Resource为各种形式的BeanDefinition的使用都提供了统一的接口) * BeanDefinition 的载入 * 向 IOC 容器中注册BeanDefinition(实际上IOC容器内部维护一个HashMap，注册过程就是将BeanDefinition添加到HashMap中)IOC 加载过程IOC 容器其实就是一个大工厂，它用来管理我们所有的对象以及依赖关系： * 根据 Bean 配置信息在容器内部创建 Bean 定义注册表 * 根据注册表加载，实例化 Bean，建立 Bean 与 Bean 之间的依赖关系 * 将 Bean 实例放入 Spring IoC 容器中，等待应用程序调用 BeanFactory 和 ApplicationContextBeanFactory * IOC 容器要实现的最基础的接口 * 采用延迟初始化策略(容器初始化完成后并不会创建 Bean 对象，只有当收到初始化请求时才进行初始化) * 由于是延迟初始化策略，因此启动速度较快，占用资源较少ApplicationConext * 在 BeanFactory 基础上，增加了更为高级的特性：事件发布、国际化等。 * 在容器启动时，完成所有 Bean 的创建 * 启动时间较长，占用资源较多BeanFactory 和 FactoryBean 的区别 BeanFactory 是 IOC 最基本的容器，负责生产和管理 Bean，为其他具体的 IOC 容器提供了最基本的规范。 FactoryBean 是一个 Bean，是一个接口，当 IOC 容器中的 Bean 实现了 FactoryBean 后，通过 getBean(String beanName) 获取到的 Bean 对象并不是 FactoryBean 的实现类对象，而是这个 实现类中的 getObject() 方法返回的对象。要想获取 FactoryBean 的实现类对象，就要在 beanName 前面加上 &quot;&amp;&quot;。BeanFactory 和 对象 的区别 bean在Spring中有生命周期，创建和依赖关系交由Spring管理，对象随时都可以new出来的，由JVM管理 getBean 代码逻辑* 获取参数 name 转化为 beanName * 从缓存中加载实例 * 实例化 Bean * 检测 parentBeanFactory（若无缓存数据，直接到 parentBeanFactory 中去加载） * 初始化依赖的 Bean * 返回 BeanSpring 循环依赖类的实例化和类的初始化 * 类的实例化是指创建一个类的实例(对象)的过程 * 类的初始化是指为类中各个类成员(被static修饰的成员变量)赋初始值的过程，是类生命周期中的一个阶段。在 Spring 容器中我们的类又是什么时候进行初始化和实例化的呢？ * Spring 中所有 Bean 默认都是单例模式，所以 Bean 的初始化和实例化都是在加载进入 Bean 容器时做的 * 如果想使用时再初始化，那么可以把类定义为原型模式 容器中默认单例bean则支持，prototype原型bean(每次请求时，创建新的bean)不支持解决循环依赖只有单例对象才满足Spring解决循环依赖问题，在 Spring IoC 容器中，有且仅有一个对象，将对象放入缓存中。Spring 中使用“三级缓存”： * SingletonObjects：单例对象的缓存（存储实例化完成的 Bean） * earlySingletonObjects：提前曝光的单例对象的缓存（存储正在实例化的 Bean） * SingletonFactories：单例对象工厂 ObjectFactory 的缓存123456/** Cache of singleton objects: bean name --&gt; bean instance */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);/** Cache of singleton factories: bean name --&gt; ObjectFactory */private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);/** Cache of early singleton objects: bean name --&gt; bean instance */private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16); Spring 中单例对象的初始化主要分为 3 步： *第一步：createBeanInstance 实例化，实际上就是调用对应的构造方法构造对象，此时只是调用了构造方法，spring xml中指定的property并没有进行populate *第二步：populateBean 填充属性，这步对spring xml中指定的property进行populate *第三步：intializeBean 初始化 调用spring xml中指定的init方法，或者AfterPropertiesSet方法 会发生循环依赖的步骤集中在第一步和第二步。在进行 createBeanInstance 后，该单例对象此时已被创建，Spring 将该对象提前曝光到 SingeltonFacoties 中。 * A 完成 createBeanInstance ，并且提前曝光到 SingeltonFacoties 中 * A 进行第二步，发现需要依赖 B，尝试获取 B * B 开始创建，B 完成 createBeanInstance，发现需要依赖 A，尝试获取 A：先尝试从 SingletonObjects 中获取，发现不存在，因为 A 未初始化完全；再尝试从 earlySingletonObjects 中获取；再去 SingeltonFacoties 中获取，此时 B 获取 A，并将 A 放入 earlySingletonObjects 中，再删除 A 在 SingeltonFacoties 中对应的 ObjectFactory。 * B 获取 A，顺利完成第二、三步，并将初始化完成的 B 放入 SingletonObjects 中。 * 此时返回创建 A，A 可获取 B，顺利完成第二、三步，A 初始化完成， 将 A 放入 SingletonObjects 中。注意：Spring 中循环依赖有 2 种： * 构造器循环依赖：因为提前曝光到 SingletonFactories 中的前提是需要执行构造方法，所以使用 “三级缓存” 无法解决 * setter 循环依赖总结 * 尽量不要使用基于构造器的 DI，使用基于 setter 的 DI * 使用 @Autowired 注解，让 Spring 决定合适的时机]]></content>
      <categories>
        <category>技术总览</category>
        <category>系统设计</category>
        <category>常用框架</category>
      </categories>
      <tags>
        <tag>技术总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术总览]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F%E6%8A%80%E6%9C%AF%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[计算机基础 计算机网络 操作系统 数据结构和算法 HTTP Linux Java Java基础 Java容器 JVM 运行时数据区域 Java IO 面向对象 设计模式 数据库 MySQL Redis 中间件 RabbitMQ Kafka Zookeeper ZooKeeper概述 系统设计 常用框架 Spring IOC Spring AOP Spring 事务 Spring中Bean的作用域 Spring中常见注解 SpringMVC Spring中涉及到的设计模式 Web Note Web安全 分布式 分布式系统设计理念 CAP理论 BASE理论 分布式锁 分布式事务 微服务 网站架构 工具 Maven Git Nginx Docker]]></content>
      <categories>
        <category>技术总览</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B_程序员进阶]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%96%B9%E6%B3%95%E8%AE%BA%2F%E6%8A%80%E6%9C%AF%2FB_%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[B_程序员进阶]]></content>
      <categories>
        <category>方法论</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B1_理论学科]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%96%B9%E6%B3%95%E8%AE%BA%2F%E6%8A%80%E6%9C%AF%2FB1_%E7%90%86%E8%AE%BA%E5%AD%A6%E7%A7%91%2F</url>
    <content type="text"><![CDATA[理论学科]]></content>
      <categories>
        <category>方法论</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B3_编程语言]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%96%B9%E6%B3%95%E8%AE%BA%2F%E6%8A%80%E6%9C%AF%2FB3_%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[编程语言]]></content>
      <categories>
        <category>方法论</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B2_程序员素养]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%96%B9%E6%B3%95%E8%AE%BA%2F%E6%8A%80%E6%9C%AF%2FB2_%E7%A8%8B%E5%BA%8F%E5%91%98%E7%B4%A0%E5%85%BB%2F</url>
    <content type="text"><![CDATA[程序员素养]]></content>
      <categories>
        <category>方法论</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A1_如何阅读源码]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%96%B9%E6%B3%95%E8%AE%BA%2F%E6%8A%80%E6%9C%AF%2FA1_%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[如何阅读源码]]></content>
      <categories>
        <category>方法论</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A_高效学习]]></title>
    <url>%2F2020%2F02%2F10%2F%E6%96%B9%E6%B3%95%E8%AE%BA%2F%E6%8A%80%E6%9C%AF%2FA_%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[高效学习]]></content>
      <categories>
        <category>方法论</category>
        <category>技术</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Leetcode]]></title>
    <url>%2F2020%2F02%2F09%2F%E6%96%B9%E6%B3%95%E8%AE%BA%2Fleetcode-node%2F</url>
    <content type="text"><![CDATA[LeetcodeLeetCode的题大致分成两类： 基础算法的知识：递归（深度优先DFS，广度优先BFS) 、动态规划（Dynamic Programming）、拆半查找（Binary Search）、回溯（Back tracing）、分治法（Divide and Conquer）、大量的对树，数组、链表、字符串和hash表的操作 编程题。比如：atoi，strstr，add two num，括号匹配，字符串乘法，通配符匹配，文件路径简化，Text Justification，反转单词等等。通过做这些题，可以非常好的训练你对各种情况的考虑，以及你对程序代码组织的掌控（其实就是其中的状态变量）。 分治算法 将一个难以直接解决的大问题，分割成一些规模较小的相同问题，各个击破，分而治之 分治算法常用递归实现 问题缩小的小规模可以很容易解决 问题可以分解为规模较小相同问题 子问题的解可以合并为该问题的解 各个子问题相互独立，(如果这条不满足,转为动态规划求 分治法的步骤： 分解 解决 合并 案例 快速排序 归并排序 最大子数组和 动态规划 Dynamic Pragram 复杂问题不能分解成几个子问题，而分解成一系列子问题 DP通常基于一个递推公式及一个(或多个)初始状态，当前子问题解由上一次子问题解推出 状态 状态转移方程 递推关系 动态规划算法的关键在于解决冗余，以空间换时间的技术，需要存储过程中的各种状态。可以看着是分治算法+解决冗余 使用动态规划算法的问题的特征是子问题的重叠性，否则动态规划算法不具备优势 步骤 划分问题 选择状态 确定决策并写出状态转移方程 写出规划方程 回溯法也叫 试探法。 是一种选优搜索法，按照选优条件搜索，当搜索到某一步，发现原先选择并不优或达不到目标，就退回重新选择。回溯法求解问题时，一般是一边建树，一边遍历该树；且采用非递归方法。 步骤 针对问题，定义解空间（ 这时候解空间是一个集合，且包含我们要找的最优解） 组织解空间，确定易于搜索的解空间结构，通常组织成树结构 或 图结构 深度优先搜索解空间，搜索过程中用剪枝函数避免无效搜索 案例 八皇后问题 8x8的国际象棋棋盘上放置8个皇后，使得任何一个皇后都无法直接吃掉其他的皇后。任意2个皇后都不能处于同一个 横线，纵线，斜线上。 穷举搜索法或者叫蛮力法。对可能的解的众多候选按照某种顺序逐一枚举和检验。典型的问题如选择排序和冒泡排序。 案例 背包问题 给定n个重量为 w1,w2,…,wn,定价为 v1,v2,…,vn 的物品，和一个沉重为W的背包，求这些物品中一个最有价值的子集，且能装入包中。 选择排序 冒泡排序 贪心算法不追求最优解，只找到满意解。 案例 找回零钱问题 装箱问题 赫夫曼编码 迭代法是一种不断用旧值递推新值的过程，分精确迭代和近视迭代。是用来求方程和方程组近似根的方法。迭代变量迭代关系， 迭代关系选择不合理，会导致迭代失败迭代过程控制，也就是迭代什么时候结束，不能无休止进行下去 递归递归是一种设计和描述算法的有力工具。 递归算法执行过程分 递推 和 回归 两个阶段在 递推 阶段，将大的问题分解成小的问题 在 回归 阶段，获得最简单问题的解后，逐级返回，依次得到稍微复杂情况的解，知道获得最终的结果 确定递归公式 确定边界条件 案例 斐波那契数列 快速排序 递归运行效率较低，因为有函数调用的开销，递归多次也可能造成栈溢出。 阶乘计算 参考 : 酷 壳 – CoolShell]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-node</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pascal's Triangle(118)]]></title>
    <url>%2F2020%2F01%2F16%2FPascal-s-Triangle-118%2F</url>
    <content type="text"><![CDATA[Pascal’s Triangle(118)12345678910111213141516171819/*Given a non-negative integer numRows, generate the first numRows of Pascal&apos;s triangle.杨辉三角：每个数都是它左上方和右上方的数的和 n[i] = (n-1)[i] + (n-1)[i+1]*/func generate(numRows int) [][]int&#123; ret := make([][]int, numRows) for i := 0; i &lt; numRows; i++ &#123; numberOfItems := i + 1 ret[i] = make([]int, numberOfItems) for j := 0; j &lt; numberOfItems; j++ &#123; if j == 0 || j == numberOfItems-1 &#123; ret[i][j] = 1 &#125; else &#123; ret[i][j] = ret[i-1][j-1] + ret[i-1][j] &#125; &#125; &#125; return ret&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Missing Number(268)]]></title>
    <url>%2F2020%2F01%2F15%2FMissing-Number-268%2F</url>
    <content type="text"><![CDATA[Missing Number(268)1234567891011121314151617/*Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.Input: [3,0,1]Output: 2Input: [9,6,4,2,3,5,7,0,1]Output: 8*/func missingNumber(nums []int) int &#123; var sum int var ind int for i, v := range nums&#123; sum += v ind += i + 1 &#125; return ind - sum&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Best Time to Buy and Sell Stock II(122)]]></title>
    <url>%2F2020%2F01%2F14%2FBest-Time-to-Buy-and-Sell-Stock-II-122%2F</url>
    <content type="text"><![CDATA[Best Time to Buy and Sell Stock II(122)1234567891011121314/*Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).Input: [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.*/ 123456789func maxProfit(prices []int) int &#123; var ret int for i := 1; i &lt; len(prices); i++&#123; if(prices[i] &gt; prices[i-1])&#123; ret += prices[i] - prices[i-1] &#125; &#125; return ret&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contains Duplicate(217)]]></title>
    <url>%2F2020%2F01%2F11%2FContains-Duplicate-217%2F</url>
    <content type="text"><![CDATA[Contains Duplicate(217)123456789/*Given an array of integers, find if the array contains any duplicates.Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.Input: [1,2,3,4]Output: falseInput: [1,1,1,3,3,4,3,2,4,2]Output: true*/ 123456789101112func containsDuplicate(nums []int) bool &#123; var mp = make(map[int]int) for i, v := range nums&#123; _, ok := mp[v] if ok&#123; return true &#125; mp[v] = i &#125; return false&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Find All Numbers Disappeared in an Array(448)]]></title>
    <url>%2F2020%2F01%2F10%2FFind-All-Numbers-Disappeared-in-an-Array-448%2F</url>
    <content type="text"><![CDATA[Find All Numbers Disappeared in an Array(448)1234567891011/*Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.Find all the elements of [1, n] inclusive that do not appear in this array.Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.Input:[4,3,2,7,8,2,3,1]Output:[5,6]*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func findDisappearedNumbers2(nums []int) []int &#123; for i := range nums &#123; for nums[nums[i]-1] != nums[i] &#123; nums[nums[i]-1], nums[i] = nums[i], nums[nums[i]-1] &#125; &#125; out := []int&#123;&#125; for i, v := range nums &#123; if v != i+1 &#123; out = append(out, i+1) &#125; &#125; return out&#125;func findDisappearedNumbers(nums []int) []int &#123; for i := 0; i &lt; len(nums); i++&#123; if i + 1 == nums[i] || nums[i] == 0&#123; continue &#125; if nums[i] == nums[nums[i]-1]&#123; nums[i] = 0 continue &#125; nums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i] i-- &#125; for i := 0; i &lt; len(nums); i++&#123; if nums[i] == 0&#123; nums[i] = i + 1 continue &#125; nums[i] = 0 &#125; for i := 0; i &lt; len(nums); i++&#123; if nums[i] == 0&#123; nums = append(nums[:i], nums[i+1:]...) i-- &#125; &#125; return nums&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Majority Element(169)]]></title>
    <url>%2F2020%2F01%2F09%2FMajority-Element-169%2F</url>
    <content type="text"><![CDATA[Majority Element(169)12345678/*Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.You may assume that the array is non-empty and the majority element always exist in the array.Input: [2,2,1,1,1,2,2]Output: 2*/ 12345678910111213141516func majorityElement(nums []int) int &#123; n := len(nums) n = n/2 m := make(map[int]int) for _, value := range nums&#123; m[value]++ &#125; for index, value := range m&#123; if value &gt; n&#123; return index &#125; &#125; return 0&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Monotonic Array(896)]]></title>
    <url>%2F2020%2F01%2F08%2FMonotonic-Array-896%2F</url>
    <content type="text"><![CDATA[Monotonic Array(896)1234567/*An array is monotonic if it is either monotone increasing or monotone decreasing.An array A is monotone increasing if for all i &lt;= j, A[i] &lt;= A[j]. An array A is monotone decreasing if for all i &lt;= j, A[i] &gt;= A[j].Return true if and only if the given array A is monotonic.判断是否单调递增或递减*/ 123456789101112131415161718192021222324252627func isMonotonic(A []int) bool &#123; nums := len(A) if nums &lt;= 1&#123; return true &#125; else&#123; if A[0] &lt; A[nums-1]&#123; for i := 0; i &lt; nums-1; i++&#123; if A[i] &gt; A[i+1]&#123; return false &#125; &#125; &#125; else if A[0] == A[nums-1]&#123; for i := 0; i &lt; nums-1; i++&#123; if A[i] != A[i+1]&#123; return false &#125; &#125; &#125; else&#123; for i := 0; i &lt; nums-1; i++&#123; if A[i] &lt; A[i+1]&#123; return false &#125; &#125; &#125; &#125; return true&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toeplitz Matrix(766)]]></title>
    <url>%2F2020%2F01%2F06%2FToeplitz-Matrix-766%2F</url>
    <content type="text"><![CDATA[Toeplitz Matrix(766)12345678910111213141516/*A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.Now given an M x N matrix, return True if and only if the matrix is Toeplitz.Input:matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2]]Output: TrueExplanation:In the above grid, the diagonals are:&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.In each diagonal all elements are the same, so the answer is True.*/ 1234567891011121314151617func isToeplitzMatrix(matrix [][]int) bool &#123; for i := len(matrix) - 1; i &gt;= 0; i-- &#123; for t := 0; t &lt; len(matrix[0]); t++ &#123; x := i + 1 y := t + 1 for x &lt; len(matrix) &amp;&amp; y &lt; len(matrix[0]) &#123; if matrix[x][y] != matrix[i][t] &#123; return false &#125; x++ y++ &#125; &#125; &#125; return true&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fibonacci Number(509)]]></title>
    <url>%2F2020%2F01%2F04%2FFibonacci-Number-509%2F</url>
    <content type="text"><![CDATA[Fibonacci Number(509)12345678910/*Fibonacci Number*/func fib(N int) int &#123; a, b := 0, 1 for ; N &gt; 0; N--&#123; a, b = b, a + b &#125; return a&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sort Array By Parity(905)]]></title>
    <url>%2F2020%2F01%2F02%2FSort-Array-By-Parity-905%2F</url>
    <content type="text"><![CDATA[Sort Array By Parity(905)1234567891011121314151617181920/*Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.You may return any answer array that satisfies this condition.Input: [3,1,2,4]Output: [2,4,3,1]The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.*/func sortArrayByParity(A []int) []int &#123; var even []int var odd []int for _, v := range A&#123; if v %2 == 0&#123; even = append(even, v) &#125; else&#123; odd = append(odd, v) &#125; &#125; return append(even, odd...) &#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flipping an Image(832)]]></title>
    <url>%2F2019%2F12%2F31%2FFlipping-an-Image-832%2F</url>
    <content type="text"><![CDATA[Flipping an Image(832)123456789101112131415/*Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].Example 1:Input: [[1,1,0],[1,0,1],[0,0,0]]Output: [[1,0,0],[0,1,0],[1,1,1]]Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]Example 2:Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]*/ func flipAndInvertImage(a [][]int) [][]int { for k, row := range a{ a[k] = invert(row) } return a } func invert(a []int) []int{ for i, j := 0, len(a) - 1; j &gt;= i; i, j = i + 1, j - 1{ a[i], a[j] = reverse(a[j]), reverse(a[i]) } return a } func reverse(a int) int{ if a == 0{ return 1 } else{ return 0 } }]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Search Insert Position(35)]]></title>
    <url>%2F2019%2F12%2F30%2FSearch-Insert-Position-35%2F</url>
    <content type="text"><![CDATA[Search Insert Position(35)12345678/*Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.Input: [1,3,5,6], 5Output: 2Input: [1,3,5,6], 7Output: 4*/ 1234567891011121314151617func searchInsert(nums []int, target int) int &#123; if nums == nil&#123; return -1 &#125; right, left := 0, len(nums)-1 for right &lt;= left&#123; mid := (right+left)/2 if nums[mid] == target&#123; return mid &#125; else if nums[mid] &gt; target&#123; left = mid - 1 &#125; else&#123; right = mid + 1 &#125; &#125; return right&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rotate Array(189)]]></title>
    <url>%2F2019%2F12%2F29%2FRotate-Array-189%2F</url>
    <content type="text"><![CDATA[Rotate Array(189)12345678910/*Given an array, rotate the array to the right by k steps, where k is non-negative.Input: [1,2,3,4,5,6,7] and k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4]*/ 123456789101112131415161718192021222324func rotate(nums []int, k int) &#123; if nums == nil || k &lt; 0&#123; return &#125; k %= len(nums) reverse(nums, 0, len(nums)-1) reverse(nums, 0, k-1) reverse(nums, k, len(nums)-1) &#125;func reverse(nums []int, n1 int, n2 int)&#123; for n1 &lt; n2&#123; nums[n1], nums[n2] = nums[n2], nums[n1] n1++ n2-- &#125;&#125;func rotate2(nums []int, k int)&#123; if len(nums) != 0&#123; copy(nums, append(nums[len(nums) - k % len(nums): ], nums[0:len(nums) - k % len(nums)]...)) &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>array</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Single Number(136)]]></title>
    <url>%2F2019%2F12%2F28%2FSingle-Number-136%2F</url>
    <content type="text"><![CDATA[Single Number(136)1234567891011121314/*Given a non-empty array of integers, every element appears twice except for one. Find that single one.Input: [2,2,1]Output: 1给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。要求算法时间复杂度是线性的，并且不使用额外的辅助空间。任何一个数字异或它自己都等于0。*/func singleNumber(nums []int) int &#123; result := 0 for i := 0; i &lt; len(nums); i++&#123; result ^= nums[i] &#125; return result&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>bit manipulation</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Letter Case Permutation(784)]]></title>
    <url>%2F2019%2F12%2F27%2FLetter-Case-Permutation-784%2F</url>
    <content type="text"><![CDATA[Letter Case Permutation(784)123456789101112/*Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create.Examples:Input: S = &quot;a1b2&quot;Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]Input: S = &quot;3z4&quot;Output: [&quot;3z4&quot;, &quot;3Z4&quot;]给定一个字符串 S，通过将字符串 S 中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。DFS 深搜或者 BFS 广搜都可以。*/ 12345678910111213141516171819202122232425262728293031323334import ( &quot;strings&quot;)func letterCasePermutation(S string) []string &#123; res := make([]string, 0) S = strings.ToLower(S) for k, v := range S&#123; if isLetter(byte(v))&#123; switch len(res)&#123; case 0: res = append(res, S, toUpper(S, k)) default: for _, s := range res&#123; res = append(res, toUpper(s, k)) &#125; &#125; &#125; &#125; if len(res) == 0&#123; res = append(res, S) &#125; return res&#125;func isLetter(c byte) bool &#123; return (c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;z&apos;) || (c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;Z&apos;)&#125;func toUpper(s string, i int) string &#123; b := []byte(s) b[i] -= &apos;a&apos; - &apos;A&apos; return string(b)&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>backtracking</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valid Anagram(242)]]></title>
    <url>%2F2019%2F12%2F25%2FValid-Anagram-242%2F</url>
    <content type="text"><![CDATA[Valid Anagram(242)123456/*Given two strings s and t , write a function to determine if t is an anagram of s.Input: s = &quot;anagram&quot;, t = &quot;nagaram&quot;Output: true给出 2 个字符串 s 和 t，如果 t 中的字母在 s 中都存在，输出 true，否则输出 false。*/ 1234567891011121314151617181920func isAnagram(s string, t string) bool &#123; alphabet := make([]int, 26) sBytes := []byte(s) tBytes := []byte(t) if len(sBytes) != len(tBytes) &#123; return false &#125; for i := 0; i &lt; len(sBytes); i++ &#123; alphabet[sBytes[i]-&apos;a&apos;]++ &#125; for i := 0; i &lt; len(tBytes); i++ &#123; alphabet[tBytes[i]-&apos;a&apos;]-- &#125; for i := 0; i &lt; 26; i++ &#123; if alphabet[i] != 0 &#123; return false &#125; &#125; return true&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Largest Perimeter Triangle(976)]]></title>
    <url>%2F2019%2F12%2F24%2FLargest-Perimeter-Triangle-976%2F</url>
    <content type="text"><![CDATA[Largest Perimeter Triangle(976)12345678910111213141516171819202122/*Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.If it is impossible to form any triangle of non-zero area, return 0.找到可以组成三角形三条边的长度，要求输出三条边之和最长的，即三角形周长最长。将所有的长度进行排序，从大边开始往前找，找到第一个任意两边之和大于第三边(满足能构成三角形的条件)的下标，然后输出这 3 条边之和即可，如果没有找到输出 0 。*/import &quot;sort&quot;func largestPerimeter(A []int) int &#123; if len(A) &lt; 3&#123; return 0 &#125; sort.Ints(A) for i := len(A) - 1; i &gt;= 2; i--&#123; if A[i] &lt; A[i-1] + A[i-2]&#123; return A[i] + A[i-1] + A[i-2] &#125; &#125; return 0&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sort Array By Parity II(922)]]></title>
    <url>%2F2019%2F12%2F23%2FSort-Array-By-Parity-II-922%2F</url>
    <content type="text"><![CDATA[Sort Array By Parity II(922)1234567891011121314151617181920212223242526/*Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even.Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.You may return any answer array that satisfies this condition.要求数组中奇数下标位置上放奇数，偶数下标位置上放偶数。*/func sortArrayByParityII(A []int) []int &#123; if len(A) == 0 || len(A)%2 != 0 &#123; return []int&#123;&#125; &#125; res := make([]int, len(A)) oddIndex := 1 evenIndex := 0 for i := 0; i &lt; len(A); i++ &#123; if A[i]%2 == 0 &#123; res[evenIndex] = A[i] evenIndex += 2 &#125; else &#123; res[oddIndex] = A[i] oddIndex += 2 &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Remove Linked List Elements(203)]]></title>
    <url>%2F2019%2F12%2F22%2FRemove-Linked-List-Elements-203%2F</url>
    <content type="text"><![CDATA[Remove Linked List Elements(203)1234567891011/*Remove all elements from a linked list of integers that have value val.Input: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6Output: 1-&gt;2-&gt;3-&gt;4-&gt;5删除链表中所有指定值的结点。*/type ListNode struct&#123; Val int Next *ListNode&#125; 123456789101112131415161718func removeElements(head *ListNode, val int) *ListNode &#123; if head == nil&#123; return head &#125; newHead := &amp;ListNode&#123;0, head&#125; pre := newHead cur := head for cur != nil&#123; if cur.Val == val&#123; pre.Next = cur.Next &#125; else&#123; pre = cur &#125; cur = cur.Next &#125; return newHead.Next&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>linked list</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intersection of Two Linked Lists(160)]]></title>
    <url>%2F2019%2F12%2F22%2FIntersection-of-Two-Linked-Lists-160%2F</url>
    <content type="text"><![CDATA[Intersection of Two Linked Lists(160)1234567891011/*Write a program to find the node at which the intersection of two singly linked lists begins.把 B 拼接到 A 后面，把 A 拼接到 B 后面。这样 2 个链表的长度都是 A + B。再依次扫描比较 2 个链表的结点是否相同。*/type ListNode struct&#123; Val int Next *ListNode&#125; 123456789101112131415161718192021func getIntersectionNode(headA, headB *ListNode) *ListNode &#123; if headA == nil || headB == nil&#123; return nil &#125; a := headA b := headB for a != b&#123; if a == nil&#123; a = headB &#125; else&#123; a = a.Next &#125; if b == nil&#123; b = headA &#125; else&#123; b = b.Next &#125; &#125; return a&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>linked list</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Delete Node in a Linked List(237)]]></title>
    <url>%2F2019%2F12%2F21%2FDelete-Node-in-a-Linked-List-237%2F</url>
    <content type="text"><![CDATA[Delete Node in a Linked List(237)12345678910111213/*Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.Input: head = [4,5,1,9], node = 5Output: [4,1,9]Input: head = [4,5,1,9], node = 1Output: [4,5,9]*/type ListNode struct&#123; Val int Next *ListNode&#125; 123456789101112func deleteNode(node *ListNode) &#123; if node == nil&#123; return &#125; cur := node for cur.Next.Next != nil&#123; cur.Val = cur.Next.Val cur = cur.Next &#125; cur.Val = cur.Next.Val cur.Next = nil&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>linked list</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse Linked List(206)]]></title>
    <url>%2F2019%2F12%2F19%2FReverse-Linked-List-206%2F</url>
    <content type="text"><![CDATA[Reverse Linked List(206)12345678910111213141516171819202122/*Reverse a singly linked list.Example:Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL*/type ListNode struct&#123; Val int Next *ListNode&#125;func reverseList(head *ListNode) *ListNode &#123; var pre *ListNode for head != nil&#123; next := head.Next head.Next = pre pre = head head = next &#125; return pre&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>linked list</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Middle of the Linked List(876)]]></title>
    <url>%2F2019%2F12%2F18%2FMiddle-of-the-Linked-List-876%2F</url>
    <content type="text"><![CDATA[Middle of the Linked List(876)12345678910/*Given a non-empty, singly linked list with head node head, return a middle node of linked list.If there are two middle nodes, return the second middle node.Input: [1,2,3,4,5]Output: Node 3输出链表中间结点。这题在前面题目中反复出现了很多次了。如果链表长度是奇数，输出中间结点是中间结点。如果链表长度是双数，输出中间结点是中位数后面的那个结点。用 2 个指针只遍历一次就可以找到中间节点。一个指针每次移动 2 步，另外一个指针每次移动 1 步，当快的指针走到终点的时候，慢的指针就是中间节点。*/ 1234567891011121314151617181920212223242526type ListNode struct &#123; Val int Next *ListNode&#125;func middleNode(head *ListNode) *ListNode &#123; if head == nil || head.Next == nil&#123; return head &#125; p1 := head p2 := head for p2.Next != nil &amp;&amp; p2.Next.Next != nil&#123; p1 = p1.Next p2 = p2.Next.Next &#125; length := 0 cur := head for cur != nil&#123; cur = cur.Next length++ &#125; if length % 2 == 0&#123; return p1.Next &#125; return p1&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>linked list</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Remove Duplicates from Sorted List(83)]]></title>
    <url>%2F2019%2F12%2F17%2FRemove-Duplicates-from-Sorted-List-83%2F</url>
    <content type="text"><![CDATA[Remove Duplicates from Sorted List(83)123456/*Given a sorted linked list, delete all duplicates such that each element appear only once.Example 1:Input: 1-&gt;1-&gt;2Output: 1-&gt;2*/ 12345678910111213141516171819type ListNode struct&#123; Val int Next *ListNode&#125;func deleteDuplicates(head *ListNode) *ListNode &#123; cur := head if head == nil&#123; return nil &#125; for cur.Next != nil&#123; if cur.Next.Val == cur.Val&#123; cur.Next = cur.Next.Next &#125; else&#123; cur = cur.Next &#125; &#125; return head&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>linked list</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Merge Two Sorted Lists(21)]]></title>
    <url>%2F2019%2F12%2F16%2FMerge-Two-Sorted-Lists-21%2F</url>
    <content type="text"><![CDATA[Merge Two Sorted Lists(21)1234567/*Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.Example :Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344type ListNode struct&#123; Val int Next *ListNode&#125;func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode &#123; var head *ListNode head = new(ListNode) current := head for l1 != nil &amp;&amp; l2 != nil&#123; if(l1.Val &lt; l2.Val)&#123; current.Next = l1 l1 = l1.Next &#125; else&#123; current.Next = l2 l2 = l2.Next &#125; current = current.Next &#125; if l1 == nil&#123; current.Next = l2 &#125; else&#123; current.Next = l1 &#125; return head.Next&#125;func mergeTwoLists2(l1 *ListNode, l2 *ListNode) *ListNode &#123; if l1 == nil &#123; return l2 &#125; if l2 == nil &#123; return l1 &#125; if l1.Val &lt; l2.Val &#123; l1.Next = mergeTwoLists(l1.Next, l2) return l1 &#125; l2.Next = mergeTwoLists(l1, l2.Next) return l2&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>linked list</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Implement Stack using Queues(225)]]></title>
    <url>%2F2019%2F12%2F16%2FImplement-Stack-using-Queues-225%2F</url>
    <content type="text"><![CDATA[Implement Stack using Queues(225)1234567/*Implement the following operations of a stack using queues.push(x) -- Push element x onto stack.pop() -- Removes the element on top of the stack.top() -- Get the top element.empty() -- Return whether the stack is empty.*/ 1234567891011121314151617181920212223242526272829303132333435363738type MyStack struct&#123; enque []int deque []int&#125;func Constructor() MyStack&#123; return MyStack&#123;[]int&#123;&#125;, []int&#123;&#125;&#125;&#125;func (this *MyStack) Push(x int)&#123; this.enque = append(this.enque, x)&#125;func (this *MyStack) Pop() int&#123; length := len(this.enque) for i := 0; i &lt; length - 1; i++&#123; this.deque = append(this.deque, this.enque[0]) this.enque = this.enque[1:] &#125; top := this.enque[0] this.enque = this.deque this.deque = nil return top&#125;func (this *MyStack) Top() int&#123; top := this.Pop() this.enque = append(this.enque, top) return top&#125;func (this *MyStack) Empty() bool&#123; if len(this.enque) == 0&#123; return true &#125; return false&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Implement Queue using Stacks(232)]]></title>
    <url>%2F2019%2F12%2F15%2FImplement-Queue-using-Stacks-232%2F</url>
    <content type="text"><![CDATA[Implement Queue using Stacks(232)1234567/*Implement the following operations of a queue using stacks.push(x) -- Push element x to the back of queue.pop() -- Removes the element from in front of queue.peek() -- Get the front element.empty() -- Return whether the queue is empty.*/ 12345678910111213141516171819202122232425262728293031323334353637383940414243type MyQueue struct&#123; Stack *[]int Queue *[]int&#125;func Constructor() MyQueue&#123; tmp1, tmp2 := []int&#123;&#125;, []int&#123;&#125; return MyQueue&#123;Stack: &amp;tmp1, Queue: &amp;tmp2&#125;&#125;func (this *MyQueue) Pop() int&#123; if len(*this.Queue) == 0&#123; this.fromStackToQueue(this.Stack, this.Queue) &#125; pop := (*this.Queue)[len(*this.Queue)-1] *this.Queue = (*this.Queue)[:len(*this.Queue)-1] return pop&#125;func (this *MyQueue) Push(x int) &#123; *this.Stack = append(*this.Stack, x)&#125;func (this *MyQueue) Peek() int &#123; if len(*this.Queue) == 0&#123; this.fromStackToQueue(this.Stack, this.Queue) &#125; return (*this.Queue)[len(*this.Queue)-1]&#125;func (this *MyQueue) Empty() bool&#123; return len(*this.Stack) + len(*this.Queue) == 0&#125;func (this *MyQueue) fromStackToQueue(s, q *[]int)&#123; for len(*s) &gt; 0&#123; pop := (*s)[len(*s)-1] *s = (*s)[:len(*s)-1] *q = append(*q, pop) &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Min Stack(155)]]></title>
    <url>%2F2019%2F12%2F14%2FMin-Stack-155%2F</url>
    <content type="text"><![CDATA[Min Stack(155)1234567891011121314/*Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack.MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; Returns -3.minStack.pop();minStack.top(); --&gt; Returns 0.minStack.getMin(); --&gt; Returns -2.*/ 12345678910111213141516171819202122232425262728293031323334353637type MinStack struct&#123; elements, min []int l int&#125;func Constructor155() MinStack &#123; return MinStack&#123;make([]int, 0), make([]int, 0), 0&#125;&#125;func (this *MinStack) Push(x int)&#123; this.elements = append(this.elements, x) if this.l == 0&#123; this.min = append(this.min, x) &#125; else&#123; min := this.GetMin() if x &lt; min&#123; this.min = append(this.min, x) &#125; else&#123; this.min = append(this.min, min) &#125; &#125; this.l++&#125;func (this *MinStack) Pop()&#123; this.l-- this.min = this.min[:this.l] this.elements = this.elements[:this.l]&#125;func (this *MinStack) Top() int&#123; return this.elements[this.l-1]&#125;func (this *MinStack) GetMin() int&#123; return this.min[this.l-1]&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Valid Parentheses(20)]]></title>
    <url>%2F2019%2F12%2F14%2FValid-Parentheses-20%2F</url>
    <content type="text"><![CDATA[Valid Parentheses(20)1234567891011/*Given a string containing just the characters &apos;(&apos;, &apos;)&apos;, &apos;&#123;&apos;, &apos;&#125;&apos;, &apos;[&apos; and &apos;]&apos;, determine if the input string is valid.Input: &quot;()[]&#123;&#125;&quot;Output: trueInput: &quot;([)]&quot;Output: false遇到左括号就进栈push，遇到右括号并且栈顶为与之对应的左括号，就把栈顶元素出栈。最后看栈里面还有没有其他元素，如果为空，即匹配。需要注意，空字符串是满足括号匹配的，即输出 true。*/ 123456789101112131415161718func isValid(s string) bool &#123; if len(s) == 0&#123; return true &#125; stack := make([]rune, 0) for _, v := range s&#123; if (v == &apos;(&apos;) || (v == &apos;[&apos;) || (v == &apos;&#123;&apos;)&#123; stack = append(stack, v) &#125; else if ((v == &apos;]&apos;) &amp;&amp; len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] == &apos;[&apos;) || ((v == &apos;)&apos;) &amp;&amp; len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] == &apos;(&apos;) || ((v == &apos;&#125;&apos;) &amp;&amp; len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] == &apos;&#123;&apos;)&#123; stack = stack[:len(stack)-1] &#125; else&#123; return false &#125; &#125; return len(stack) == 0&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Remove All Adjacent Duplicates In String(1047)]]></title>
    <url>%2F2019%2F12%2F12%2FRemove-All-Adjacent-Duplicates-In-String-1047%2F</url>
    <content type="text"><![CDATA[Remove All Adjacent Duplicates In String(1047)123456789101112131415/*Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them.We repeatedly make duplicate removals on S until we no longer can.Return the final string after all such duplicate removals have been made. It is guaranteed the answer is unique.Input: &quot;abbaca&quot;Output: &quot;ca&quot;Explanation: For example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is &quot;aaca&quot;,of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.“对对碰” 一旦新来的字符和栈顶的字符一样的话，就弹出栈顶字符，直至扫完整个字符串。栈中剩下的字符串就是最终要输出的结果。*/ 1234567891011func removeDuplicates1047(S string) string &#123; stack := []rune&#123;&#125; for _, s := range S&#123; if len(stack) == 0 || (len(stack) &gt; 0 &amp;&amp; stack[len(stack)-1] != s) &#123; stack = append(stack, s) &#125; else&#123; stack = stack[:len(stack)-1] &#125; &#125; return string(stack)&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Remove Outermost Parentheses(1021)]]></title>
    <url>%2F2019%2F12%2F11%2FRemove-Outermost-Parentheses-1021%2F</url>
    <content type="text"><![CDATA[Remove Outermost Parentheses(1021)1234567891011/*A valid parentheses string is either empty (&quot;&quot;), &quot;(&quot; + A + &quot;)&quot;, or A + B,where A and B are valid parentheses strings, and + represents string concatenation. For example, &quot;&quot;, &quot;()&quot;, &quot;(())()&quot;, and &quot;(()(()))&quot; are all valid parentheses strings.Input: &quot;(()())(())&quot;Output: &quot;()()()&quot;Explanation: The input string is &quot;(()())(())&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot;.After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;.题目要求去掉最外层的括号*/ 12345678910111213141516func removeOuterParentheses(S string) string &#123; now, current, ans := 0, &quot;&quot;, &quot;&quot; for _, char := range S&#123; if string(char) == &quot;(&quot;&#123; now++ &#125; else if string(char) == &quot;)&quot;&#123; now-- &#125; current += string(char) if now == 0&#123; ans += current[1 : len(current) - 1] current = &quot;&quot; &#125; &#125; return ans&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>stack</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Implement strStr(28)]]></title>
    <url>%2F2019%2F12%2F10%2FImplement-strStr-28%2F</url>
    <content type="text"><![CDATA[Implement strStr(28)123456789/*Implement strStr().Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2实现一个查找 substring 的函数。如果在母串中找到了子串，返回子串在母串中出现的下标，如果没有找到，返回 -1，如果子串是空串，则返回 0 。*/ 12345678910111213141516func strStr(haystack string, needle string) int &#123; for i := 0; ; i++&#123; for j := 0; ; j++&#123; if j == len(needle)&#123; return i &#125; if i + j == len(haystack)&#123; return -1 &#125; if needle[j] != haystack[i + j]&#123; break &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindrome Linked List(234)]]></title>
    <url>%2F2019%2F12%2F09%2FPalindrome-Linked-List-234%2F</url>
    <content type="text"><![CDATA[Palindrome Linked List(234)12345678910/*Given a singly linked list, determine if it is a palindrome.Input: 1-&gt;2Output: falseInput: 1-&gt;2-&gt;2-&gt;1Output: true判断一个链表是否是回文链表。要求时间复杂度 O(n)，空间复杂度 O(1)。先找到中间结点，然后反转中间结点后面到结尾的所有结点。最后一一判断头结点开始的结点和中间结点往后开始的结点是否相等。如果一直相等，就是回文链表，如果有不相等的，直接返回不是回文链表。*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344type ListNode struct&#123; Val int Next *ListNode&#125;func isPalindrome234(head *ListNode) bool &#123; if head == nil || head.Next == nil&#123; return true &#125; res := true p1 := head p2 := head for p2.Next != nil &amp;&amp; p2.Next.Next != nil&#123; p1 = p1.Next p2 = p2.Next.Next &#125; preMiddle := p1 preCurrent := p1.Next for preCurrent.Next != nil&#123; current := preCurrent.Next preCurrent.Next = current.Next current.Next = preMiddle.Next preMiddle.Next = current &#125; p1 = head p2 = preMiddle.Next for p1 != preMiddle&#123; if p1.Val == p2.Val&#123; p1 = p1.Next p2 = p2.Next &#125; else&#123; res = false break &#125; &#125; if p1 == preMiddle&#123; if p2 != nil &amp;&amp; p1.Val != p2.Val&#123; return false &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Merge Sorted Array(88)]]></title>
    <url>%2F2019%2F12%2F08%2FMerge-Sorted-Array-88%2F</url>
    <content type="text"><![CDATA[Merge Sorted Array(88)123456/*Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.合并两个已经有序的数组，结果放在第一个数组中，第一个数组假设空间足够大。要求算法时间复杂度足够低。为了不大量移动元素，就要从2个数组长度之和的最后一个位置开始，依次选取两个数组中大的数，从第一个数组的尾巴开始往头放，只要循环一次以后，就生成了合并以后的数组了。*/ 123456789101112131415161718192021222324func merge(nums1 []int, m int, nums2 []int, n int) &#123; if m == 0&#123; copy(nums1, nums2) return &#125; i := m - 1 j := n - 1 k := m + n - 1 for ; i &gt;= 0 &amp;&amp; j &gt;= 0; k--&#123; if nums1[i] &gt; nums2[j]&#123; nums1[k] = nums1[i] i-- &#125; else&#123; nums1[k] = nums2[j] j-- &#125; &#125; for ; j &gt;= 0; k--&#123; nums1[k] = nums2[j] j-- &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linked List Cycle(141)]]></title>
    <url>%2F2019%2F12%2F07%2FLinked-List-Cycle-141%2F</url>
    <content type="text"><![CDATA[Linked List Cycle(141)1234567891011121314151617181920212223/*Given a linked list, determine if it has a cycle in it.判断链表是否有环，不能使用额外的空间。给 2 个指针，一个指针是另外一个指针的下一个指针。快指针一次走 2 格，慢指针一次走 1 格。如果存在环，那么前一个指针一定会经过若干圈之后追上慢的指针。*/type ListNode struct &#123; Val int Next *ListNode&#125;func hasCycle(head *ListNode) bool &#123; fast := head slow := head for slow != nil &amp;&amp; fast != nil &amp;&amp; fast.Next != nil&#123; fast = fast.Next.Next slow = slow.Next if slow == fast&#123; return true &#125; &#125; return false&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse Vowels of a String(345)]]></title>
    <url>%2F2019%2F12%2F05%2FReverse-Vowels-of-a-String-345%2F</url>
    <content type="text"><![CDATA[### 123456789/*Write a function that takes a string as input and reverse only the vowels of a string.Example 1:Input: &quot;hello&quot;Output: &quot;holle&quot;题目要求我们反转字符串中的元音字母。需要注意字母大小写。解题思路这一题的解题思路是用 2 个指针，指针对撞的思路，来不断交换首尾元素*/ 12345678910111213141516171819202122232425func reverseVowels(s string) string &#123; b := []byte(s) for i, j := 0, len(b)-1; i &lt; j; &#123; if isVowels(b[i]) &amp;&amp; isVowels(b[j]) &#123; b[i], b[j] = b[j], b[i] i++ j-- &#125; else if isVowels(b[i]) &amp;&amp; !isVowels(b[j]) &#123; j-- &#125; else if !isVowels(b[i]) &amp;&amp; isVowels(b[j]) &#123; i++ &#125; else &#123; i++ j-- &#125; &#125; return string(b)&#125;func isVowels(s byte) bool&#123; if s == &apos;a&apos; || s == &apos;e&apos; || s == &apos;i&apos; || s == &apos;o&apos; || s == &apos;u&apos; || s == &apos;A&apos; || s == &apos;E&apos; || s == &apos;I&apos; || s == &apos;O&apos; || s == &apos;U&apos; &#123; return true &#125; return false&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Remove Duplicates from Sorted Array(26)]]></title>
    <url>%2F2019%2F12%2F04%2FRemove-Duplicates-from-Sorted-Array-26%2F</url>
    <content type="text"><![CDATA[Remove Duplicates from Sorted Array(26)1234567891011/*Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.Example 1:Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&apos;t matter what you leave beyond the returned length.题目大意给定一个有序数组 nums，对数组中的元素进行去重，使得原数组中的每个元素只有一个。最后返回去重以后数组的长度值。*/ 12345678910111213141516171819func removeDuplicates(nums []int) int &#123; if len(nums) == 0&#123; return 0 &#125; last, finder := 0, 0 for last &lt; len(nums) - 1&#123; for nums[finder] == nums[last]&#123; finder++ if finder == len(nums)&#123; return last + 1 &#125; &#125; nums[last+1] = nums[finder] last++ &#125; return last + 1&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Long Pressed Name(925)]]></title>
    <url>%2F2019%2F12%2F03%2FLong-Pressed-Name-925%2F</url>
    <content type="text"><![CDATA[### 123456789101112131415161718/*Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.Input: name = &quot;alex&quot;, typed = &quot;aaleex&quot;Output: trueExplanation: &apos;a&apos; and &apos;e&apos; in &apos;alex&apos; were long pressed.Input: name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot;Output: falseExplanation: &apos;e&apos; must have been pressed twice, but it wasn&apos;t in the typed output.题目大意给定 2 个字符串，后者的字符串中包含前者的字符串。比如在打字的过程中，某个字符会多按了几下。判断后者字符串是不是比前者字符串存在这样的“长按”键盘的情况。解题思路这一题也可以借助滑动窗口的思想。2 个字符串一起比较，如果遇到有相同的字符串，窗口继续往后滑动。直到遇到了第一个不同的字符，如果遇到两个字符串不相等的情况，可以直接返回 false。*/ 123456789101112131415161718192021222324func isLongPressedName(name string, typed string) bool &#123; if len(name) == 0 &amp;&amp; len(typed) == 0&#123; return true &#125; if (len(name) == 0 &amp;&amp; len(typed) != 0) || (len(name) != 0 &amp;&amp; len(typed) == 0)&#123; return false &#125; j := 0 for i := 0; i &lt; len(name); i++&#123; if j &lt; len(typed) &amp;&amp; name[i] == typed[j]&#123; j++ continue &#125; else&#123; if i &gt; 0 &amp;&amp; j &lt; len(typed) &amp;&amp; name[i-1] == typed[j]&#123; j++ i-- &#125; else&#123; return false &#125; &#125; &#125; return true&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Remove Element(27)]]></title>
    <url>%2F2019%2F12%2F02%2FRemove-Element-27%2F</url>
    <content type="text"><![CDATA[Remove Element(27)123456789101112131415161718/*Given an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.The order of elements can be changed. It doesn&apos;t matter what you leave beyond the new length.Example 1:Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn&apos;t matter what you leave beyond the returned length.Example 2:Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&apos;t matter what values are set beyond the returned length.题目大意给定一个数组 nums 和一个数值 val，将数组中所有等于 val 的元素删除，并返回剩余的元素个数。*/ 123456789101112131415161718func removeElement(nums []int, val int) int&#123; if len(nums) == 0&#123; return 0 &#125; j := 0 for i := 0; i &lt; len(nums); i++&#123; if nums[i] != val&#123; if i != j&#123; nums[i], nums[j] = nums[j], nums[i] j++ &#125; else&#123; j++ &#125; &#125; &#125; return j&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Backspace String Compare(844)]]></title>
    <url>%2F2019%2F12%2F01%2FBackspace-String-Compare-844%2F</url>
    <content type="text"><![CDATA[Backspace String Compare(844)123456789101112131415/*Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.Input: S = &quot;ab#c&quot;, T = &quot;ad#c&quot;Output: trueExplanation: Both S and T become &quot;ac&quot;.Input: S = &quot;ab##&quot;, T = &quot;c#d#&quot;Output: trueExplanation: Both S and T become &quot;&quot;.给 2 个字符串，如果遇到 # 号字符，就回退一个字符。问最终的 2 个字符串是否完全一致。解题思路这一题可以用栈的思想来模拟，遇到 # 字符就回退一个字符。不是 # 号就入栈一个字符。比较最终 2 个字符串即可。*/ 1234567891011121314151617181920212223func backspaceCompare(S string, T string) bool&#123; s := make([]rune, 0) for _, c := range S &#123; if c == &apos;#&apos; &#123; if len(s) &gt; 0 &#123; s = s[:len(s)-1] &#125; &#125; else &#123; s = append(s, c) &#125; &#125; s2 := make([]rune, 0) for _, c := range T &#123; if c == &apos;#&apos; &#123; if len(s2) &gt; 0 &#123; s2 = s2[:len(s2)-1] &#125; &#125; else &#123; s2 = append(s2, c) &#125; &#125; return string(s) == string(s2)&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intersection of Two Arrays(350)]]></title>
    <url>%2F2019%2F12%2F01%2FIntersection-of-Two-Arrays-350%2F</url>
    <content type="text"><![CDATA[Intersection of Two Arrays(350)1234567891011121314151617181920212223242526/*Given two arrays, write a function to compute their intersection.Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2]Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9]这题是第 349 题的加强版。要求输出 2 个数组的交集元素，如果元素出现多次，要输出多次。把数组一中的数字都放进字典中，另外字典的 key 是数组中的数字，value 是这个数字出现的次数。在扫描数组二的时候，每取出一个存在的数组，把字典中的 value 减一。如果 value 是 0 代表不存在这个数字。*/func intersect(nums1 []int, nums2 []int) []int&#123; m := make(map[int]int) var res []int for _, n := range nums1&#123; m[n]++ &#125; for _, n := range nums2&#123; if(m[n] &gt; 0)&#123; res = append(res, n) m[n]-- &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[twoSum(167)]]></title>
    <url>%2F2019%2F11%2F30%2FtwoSum167%2F</url>
    <content type="text"><![CDATA[twoSum(167)12345678910111213141516/*Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.Note:Your returned answers (both index1 and index2) are not zero-based.You may assume that each input would have exactly one solution and you may not use the same element twice.Example:Input: numbers = [2,7,11,15], target = 9Output: [1,2]Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.找出两个数之和等于 target 的两个数字，要求输出它们的下标。注意一个数字不能使用 2 次。下标从小到大输出。假定题目一定有一个解。*/ 12345678910111213141516171819202122232425func twoSum167(numbers []int, target int) []int &#123; i, j := 0, len(numbers) - 1 for i &lt;= j&#123; if numbers[i] + numbers[j] &gt; target&#123; j-- &#125; else if(numbers[i] + numbers[j] &lt; target)&#123; i++ &#125; else&#123; return []int&#123;i+1, j+1&#125; &#125; &#125; return []int&#123;-1, -1&#125;&#125;func twoSum167_1(numbers []int, target int) []int &#123; m := make(map[int]int) for i := 0; i &lt; len(numbers); i++ &#123; another := target - numbers[i] if _, ok := m[another]; ok &#123; return []int&#123;m[another] + 1, i + 1&#125; &#125; m[numbers[i]] = i &#125; return nil&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intersection of Two Arrays(349)]]></title>
    <url>%2F2019%2F11%2F27%2FIntersection-of-Two-Arrays-349%2F</url>
    <content type="text"><![CDATA[Intersection of Two Arrays(349)1234567891011/*Given two arrays, write a function to compute their intersection.Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2]Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [9,4]找到两个数组的交集元素，如果交集元素同一个数字出现了多次，只输出一次。解题思路把数组一的每个数字都存进字典中，然后在数组二中依次判断字典中是否存在，如果存在，在字典中删除它(因为输出要求只输出一次)。*/ 12345678910111213141516func intersection(nums1 []int, nums2 []int) []int&#123; m := map[int]bool&#123;&#125; var res []int for _, n := range nums1&#123; m[n] = true &#125; for _, n := range nums2&#123; if m[n]&#123; delete(m, n) res = append(res, n) &#125; &#125; return res&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse String(easy)]]></title>
    <url>%2F2019%2F11%2F26%2FReverse-String-easy%2F</url>
    <content type="text"><![CDATA[Reverse String(easy)12345678910111213141516171819/*Write a function that reverses a string. The input string is given as an array of charactersExample 1: Input: [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]Input: [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]Output: [&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]题目要求我们反转一个字符串。解题思路这一题的解题思路是用 2 个指针，指针对撞的思路，来不断交换首尾元素，即可。*/func reverseString(s []byte)&#123; for i, j := 0, len(s)-1; i &lt; j; &#123; s[i], s[j] = s[j], s[i] i++ j-- &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Squares of a Sorted Array(easy)]]></title>
    <url>%2F2019%2F11%2F25%2FSquares-of-a-Sorted-Array-easy%2F</url>
    <content type="text"><![CDATA[Squares of a Sorted Array(easy)Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order. Example 1: Input: [-4,-1,0,3,10]Output: [0,1,9,16,100]Example 2: Input: [-7,-3,2,3,11]Output: [4,9,9,49,121] 解题思路这一题由于原数组是有序的，所以要尽量利用这一特点来减少时间复杂度。 最终返回的数组，最后一位，是最大值，这个值应该是由原数组最大值，或者最小值得来的，所以可以从数组的最后一位开始排列最终数组。用 2 个指针分别指向原数组的首尾，分别计算平方值，然后比较两者大小，大的放在最终数组的后面。然后大的一个指针移动。直至两个指针相撞，最终数组就排列完成了。 1234567891011121314151617181920212223func sortedSquares(A []int) []int&#123; ans := make([]int, len(A)) for i, k, j := 0, len(A)-1, len(ans)-1; i &lt;= j; k-- &#123; if A[i]*A[i] &gt; A[j]*A[j] &#123; ans[k] = A[i] * A[i] i++ &#125; else &#123; ans[k] = A[j] * A[j] j-- &#125; &#125; return ans&#125;func sorted(A []int) []int&#123; for i, value := range A&#123; A[i] = value * value &#125; sort.Ints(A) return A &#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>leetcode-go</category>
        <category>two pointers</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在排序数组中查找元素的第一个和最后一个位置（34）]]></title>
    <url>%2F2019%2F11%2F23%2F%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%8834%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在排序数组中查找元素的第一个和最后一个位置（34）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 给定一个按照升序排列的整数数组 nums，和一个目标值 target。// 找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。// 如果数组中不存在目标值，返回 [-1, -1]。// 输入: nums = [5,7,7,8,8,10], target = 8// 输出: [3,4]// 输入: nums = [5,7,7,8,8,10], target = 6// 输出: [-1,-1]public class FindFirstAndLastPosition &#123; public int[] find(int[] nums, int target)&#123; int first = findFirstPos(nums, target); int last = findLastPos(nums, target); return new int[]&#123;first, last&#125;; &#125; public static int findFirstPos(int[] nums, int target)&#123; int l = 0; int r = nums.length - 1; int res = -1; while(l &lt;= r)&#123; int mid = (l + r) / 2; if(target &lt;= nums[mid])&#123; r = mid - 1; &#125; else&#123; l = mid + 1; &#125; if(target == nums[mid])&#123; res = mid; &#125; &#125; return res; &#125; public static int findLastPos(int[] nums, int target)&#123; int l = 0; int r = nums.length - 1; int res = -1; while(l &lt;= r)&#123; int mid = (l + r) / 2; if(target &gt;= nums[mid])&#123; l = mid + 1; &#125; else&#123; r = mid - 1; &#125; if(target == nums[mid])&#123; res = mid; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go 速查]]></title>
    <url>%2F2019%2F11%2F21%2Fgo-%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[go 速查github: the way to go 1234567891011121314151617181920 /****************************************************************************** * Go 编译器命令 *****************************************************************************/go command [arguments] // go 命令 [参数]go build // 编译包和依赖包go clean // 移除对象和缓存文件go doc // 显示包的文档go env // 打印go的环境变量信息go bug // 报告buggo fix // 更新包使用新的apigo fmt // 格式规范化代码go generate // 通过处理资源生成go文件go get // 下载并安装包及其依赖go install // 编译和安装包及其依赖go list // 列出所有包go run // 编译和运行go程序go test // 测试go tool // 运行给定的go工具go version // 显示go当前版本go vet // 发现代码中可能的错误 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173/******************************************************************************* * Hello World ******************************************************************************/// main.gopackage main // 包名import &quot;fmt&quot; // 导入fmt包func main() &#123; // 主函数 fmt.Println(&quot;Hello World&quot;) // 打印输出&#125;// go run main.go // 直接运行// go build &amp;&amp; ./main // 先编译成二进制文件再运行/******************************************************************************* * 操作符 ******************************************************************************/// 算数操作符+ - * / % // 加 减 乘 除 取余&amp; | ^ &amp;^ // 位与 位或 位异或 位与非&lt;&lt; &gt;&gt; // 左移 右移// 比较操作== != // 等于 不等于&lt; &lt;= // 小于 小于等于&gt; &gt;= // 大于 大于等于// 逻辑操作&amp;&amp; || ! // 逻辑与 逻辑或 逻辑非// 其他&amp; * &lt;- // 地址 指针引用 通道操作/******************************************************************************* * 声明 ******************************************************************************/a := 1 // 直接给一个未声明的变量赋值var b int // var 变量名 数据类型 来声明var c float64// 注意：使用var声明过的变量不可再使用 := 赋值a = 2const d = 1 // 常量/******************************************************************************* * 数据类型 ******************************************************************************/s := &quot;hello&quot; // 字符a := 1 // intb := 1.2 // float64c := 1 + 5i // complex128// 数组arr1 := [3]int&#123;4, 5, 6&#125; // 手动指定长度arr2 := [...]int&#123;1, 2, 3&#125; // 由golang自动计算长度// 切片sliceInt := []int&#123;1, 2&#125; // 不指定长度sliceByte := []byte(&quot;hello&quot;)// 指针a := 1point := &amp;a // 将a的地址赋给point/******************************************************************************* * 流程控制 ******************************************************************************/// fori := 10for i &gt; 0 &#123; println(i--)&#125;// if elseif i == 10 &#123; println(&quot;i == 10&quot;)&#125; else &#123; println(&quot;i != 10&quot;)&#125;// switchswitch i &#123;case 10: println(&quot;i == 10&quot;)default: println(&quot;i != 10&quot;)&#125;/******************************************************************************* * 函数 ******************************************************************************/// 以func关键字声明func test() &#123;&#125;f := func() &#123;println(&quot;Lambdas function&quot;)&#125; // 匿名函数f()func get() (a,b string) &#123; // 函数多返回值 return &quot;a&quot;, &quot;b&quot;&#125;a, b := get()/******************************************************************************* * 结构体 ******************************************************************************/// golang中没有class只有structtype People struct &#123; Age int // 大写开头的变量在包外可以访问 name string // 小写开头的变量仅可在本包内访问&#125;p1 := People&#123;25, &quot;Kaven&quot;&#125; // 必须按照结构体内部定义的顺序p2 := People&#123;name: &quot;Kaven&quot;, age: 25&#125; // 若不按顺序则需要指定字段// 也可以先不赋值p3 := new(People)p3.Age = 25p3.name = &quot;Kaven&quot;/******************************************************************************* * 方法 ******************************************************************************/// 方法通常是针对一个结构体来说的type Foo struct &#123; a int&#125; // 值接收者func (f Foo) test() &#123; f.a = 1 // 不会改变原来的值&#125; // 指针接收者func (f *Foo) test() &#123; f.a = 1 // 会改变原值&#125;/******************************************************************************* * go 协程 ******************************************************************************/go func() &#123; time.Sleep(10 * time.Second) println(&quot;hello&quot;)&#125;() // 不会阻塞代码的运行 代码会直接向下运行// channel 通道c := make(chan int)// 两个协程间可以通过chan通信go func() &#123;c &lt;- 1&#125;() // 此时c会被阻塞 直到值被取走前都不可在塞入新值go func() &#123;println(&lt;-c)&#125;()// 带缓存的channelbc := make(chan int, 2)go func() &#123;c &lt;- 1; c &lt;-2&#125;() // c中可以存储声明时所定义的缓存大小的数据，这里是2个go func() &#123;println(&lt;-c)&#125;()/******************************************************************************* * 接口 ******************************************************************************/// go的接口为鸭子类型，即只要你实现了接口中的方法就实现了该接口type Reader interface &#123; Reading() // 仅需实现Reading方法就实现了该接口&#125;type As struct &#123;&#125;func (a As) Reading() &#123;&#125; // 实现了Reader接口type Bs struct &#123;&#125;func (b Bs) Reading() &#123;&#125; // 也实现了Reader接口func (b Bs) Closing() &#123;&#125;]]></content>
      <categories>
        <category>go</category>
        <category>go 笔记</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索旋转排序数组（33）]]></title>
    <url>%2F2019%2F11%2F21%2F%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%8833%EF%BC%89%2F</url>
    <content type="text"><![CDATA[搜索旋转排序数组（33）123456789101112131415161718192021222324252627282930313233// 假设按照升序排序的数组在预先未知的某个点上进行了旋转。// ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。// 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。// 你可以假设数组中不存在重复的元素。// 输入: nums = [4,5,6,7,0,1,2], target = 0// 输出: 4// nums = [4,5,6,7,0,1,2], target = 3// 输出: -1public class SearchRotatedSort &#123; public static int find(int[] nums, int target)&#123; int l = 0; int r = nums.length - 1; while(l &lt;= r)&#123; int mid = (l + r) / 2; if(nums[mid] == target)&#123; return mid; &#125; else if(nums[mid] &gt; nums[r])&#123; // 左半部分[l,mid-1]是有序的。 if(target &gt;= nums[l] &amp;&amp; target &lt; nums[mid])&#123; r = mid - 1; &#125; else&#123; l = mid + 1; &#125; &#125; else&#123; // 右半部分[mid+1,r]是有序的。 if(target &gt; nums[mid] &amp;&amp; target &lt;= nums[r])&#123; l = mid + 1; &#125; else&#123; r = mid - 1; &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找旋转排序数组中的最小值（153）]]></title>
    <url>%2F2019%2F11%2F20%2F%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%88153%EF%BC%89%2F</url>
    <content type="text"><![CDATA[寻找旋转排序数组中的最小值（153）123456789101112131415161718192021222324// 假设按照升序排序的数组在预先未知的某个点上进行了旋转。// ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。// 输入: [3,4,5,1,2]// 输出: 1// 输入: [4,5,6,7,0,1,2]// 输出: 0public class FindMin &#123; public static int getMin(int[] array) &#123; if(array == null || array.length == 0) &#123; return -1; &#125; int left = 0; int right = array.length - 1; while(left &lt; right) &#123; int mid = (right + left) / 2; if(array[mid] &gt; array[right]) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return array[left]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[x 的平方根（69）]]></title>
    <url>%2F2019%2F11%2F18%2Fx-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%8869%EF%BC%89%2F</url>
    <content type="text"><![CDATA[x 的平方根（69）123456789101112131415161718192021222324// 实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。// 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。public class Sqrt &#123; public static int find(int x)&#123; if(x &lt;- 1) return x; int l = 0; int r = x; while(l &lt;= r)&#123; int mid = (l + r) / 2; int sqrt = x / mid; if(sqrt == mid)&#123; return mid; &#125; else if(sqrt &gt; mid)&#123; l = mid + 1; &#125; else&#123; assert sqrt &lt; mid; r = mid - 1; &#125; &#125; return r; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个错误版本（278）]]></title>
    <url>%2F2019%2F11%2F13%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%89%88%E6%9C%AC%EF%BC%88278%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第一个错误版本（278）123456789101112131415161718192021222324// 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。// 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错// 思路：// 如果第 m 个版本出错(即 isisBadVersion(mid) == true)，// 则表示第一个错误的版本在 [l, m] 之间，令 r = m ；// 否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。// 注意:这里判断条件 l &lt; rpublic class VersionControl &#123; public static int find(int n)&#123; int l = 1; int r = n; while(l &lt; n)&#123; int mid = (l + r) / 2; if(isBadVersion(mid))&#123; r = mid; &#125; else&#123; l = mid + 1; &#125; &#125; return l; &#125; public static boolean isBadVersion(int version)&#123;&#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找（704）]]></title>
    <url>%2F2019%2F11%2F12%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88704%EF%BC%89%2F</url>
    <content type="text"><![CDATA[二分查找（704）1234567891011121314151617181920212223242526// 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target// 写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。// 输入: nums = [-1,0,3,5,9,12], target = 9// 输出: 4// 解释: 9 出现在 nums 中并且下标为 4// 输入: nums = [-1,0,3,5,9,12], target = 2// 输出: -1// 解释: 2 不存在 nums 中因此返回 -1public class Search &#123; public static int search(int[] nums, int target)&#123; int l = 0; int h = nums.length - 1; while(l &lt;= h)&#123; int mid = (l + h) / 2; if(nums[mid] == target)&#123; return mid; &#125; if(nums[mid] &gt; target)&#123; h = mid - 1; &#125; else&#123; l = mid + 1; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找重复数（287）]]></title>
    <url>%2F2019%2F11%2F09%2F%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0%EF%BC%88287%EF%BC%89%2F</url>
    <content type="text"><![CDATA[寻找重复数（287）12345678910111213141516171819202122232425262728293031// 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n）// 至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。// 输入: [1,3,4,2,2]// 输出: 2// 输入: [3,1,3,4,2]// 输出: 3// 不能更改原数组（假设数组是只读的）。// 只能使用额外的 O(1) 的空间。// 时间复杂度小于 O(n2) 。// 数组中只有一个重复的数字，但它可能不止重复出现一次。public class FindDuplicate &#123; public static int find(int[] nums)&#123; int l = 0; int h = nums.length - 1; while(l &lt;= h)&#123; int mid = (h + l) / 2; int cnt = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] &lt;= mid)&#123; cnt++; &#125; &#125; if(cnt &gt; mid)&#123; h = mid - 1; &#125; else&#123; l = mid + 1; &#125; &#125; return l; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中重复的数据（442）]]></title>
    <url>%2F2019%2F11%2F08%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[数组中重复的数据（442）123456789101112131415161718192021222324252627282930313233// 给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）// 其中有些元素出现两次而其他元素出现一次。// 找到所有出现两次的元素。// 输入:// [4,3,2,7,8,2,3,1]//// 输出:// [2,3]public class FindDuplicates &#123; public static List&lt;Integer&gt; find(int[] nums)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i] != nums[nums[i]-1])&#123; swap(nums,i,nums[i]-1); i--; &#125; &#125; for(int i=0;i&lt;nums.length;i++)&#123; if(nums[i] !=i+1)&#123; res.add(nums[i]); &#125; &#125; return res; &#125; private static void swap(int[] nums,int i,int j)&#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找到所有数组中消失的数字（448）]]></title>
    <url>%2F2019%2F11%2F07%2F%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88448%EF%BC%89%2F</url>
    <content type="text"><![CDATA[找到所有数组中消失的数字（448）123456789101112131415161718192021222324252627282930313233343536// 给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的整型数组，// 数组中的元素一些出现了两次，另一些只出现一次。// 找到所有在 [1, n] 范围之间没有出现在数组中的数字。// 输入:// [4,3,2,7,8,2,3,1]//// 输出:// [5,6]public class FindDisappearedNumber &#123; public static List&lt;Integer&gt; find(int[] nums)&#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); if(nums == null || nums.length == 0)&#123; return res; &#125; for(int i = 0; i &lt;= nums.length - 1; i++)&#123; int j = i + 1; if(j != nums[i])&#123; if(nums[nums[i] - 1] != nums[i])&#123; int tmp = nums[i]; nums[i] = nums[nums[i]]; nums[nums[i]] = tmp; &#125; &#125; else&#123; continue; &#125; &#125; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != i + 1)&#123; res.add(i + 1); &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错误的集合（645）]]></title>
    <url>%2F2019%2F11%2F05%2F%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[错误的集合（645）// 集合 S 包含从1到 n 的整数。 // 导致集合丢失了一个整数并且有一个元素重复。 // 输入: nums = [1,2,2,4] // 输出: [2,3] // 给定数组的长度范围是 [2, 10000]。 // 给定的数组是无序的。 public class FindErrorNums { public static int[] find(int[] nums){ int[] a = new int[2]; for(int i = 0; i &lt;= nums.length - 1; i++){ int j = i + 1; if(j != nums[i]){ if(nums[nums[i] - 1] == nums[i]){ a[0] = i; } else{ int tmp = nums[i]; nums[i] = nums[nums[i]]; nums[nums[i]] = tmp; } } else{ continue; } } for(int i = 0; i &lt; nums.length; i++){ if(nums[i] != i+1){ a[1] = i + 1; } } return a; } public static int[] find2(int[] nums){ int[] tmp = new int[nums.length + 1]; for(int num : nums){ tmp[num]++; } int res1 = 0; int res2 = 0; for(int num = 1; num &lt;= nums.length; num++){ if(tmp[num] == 2){ res1 = num; } if(tmp[num] == 0){ res2 = num; } } return new int[]{res1, res2}; } }]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大连续1的个数（485）]]></title>
    <url>%2F2019%2F11%2F05%2F%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[最大连续1的个数（485）123456789101112131415161718192021// 给定一个二进制数组， 计算其中最大连续1的个数。// 输入: [1,1,0,1,1,1]// 输出: 3// 解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.// 输入的数组只包含 0 和1。// 输入数组的长度是正整数，且不超过 10,000public class MaxConsecutiveOnes &#123; public static int find(int[] arr)&#123; int res = 0; int count = 0; for(int n : arr)&#123; if(n == 0)&#123; count = 0; &#125; else&#123; count++; &#125; res = Math.max(res, count); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Move Zeroes(283)]]></title>
    <url>%2F2019%2F11%2F04%2FMove-Zeroes-Easy%2F</url>
    <content type="text"><![CDATA[Move Zeroes(283)1234567891011121314151617181920212223242526272829303132333435// 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。// 输入: [0,1,0,3,12]// 输出: [1,3,12,0,0]// 必须在原数组上操作，不能拷贝额外的数组。// 尽量减少操作次数。public class MoveZeroes &#123; public static void moveZeroes(int[] nums)&#123; int k = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != 0)&#123; swap(nums, k++, i); &#125; &#125; &#125; public static void swap(int[] nums, int i, int j)&#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; &#125; public static void moveAeroes2(int[] nums)&#123; int k = 0; for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != 0)&#123; if(i != k)&#123; swap(nums, k++, i); &#125; else&#123; k++; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>数组问题</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇数位于偶数前面的数组]]></title>
    <url>%2F2019%2F11%2F01%2F%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2%E7%9A%84%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[奇数位于偶数前面的数组12345678910111213141516171819202122232425262728293031323334353637// 调整数组的顺序，奇数位于偶数前面public class A14_Reorder &#123; public static void order(int[] arr)&#123; if(arr == null)&#123; return ; &#125; int left = 0; int right = arr.length - 1; while(left &lt; right)&#123; while(left &lt; right &amp;&amp; judgeCdn(arr[right]))&#123; right--; &#125; while(left &lt; right &amp;&amp; judgeCdn(arr[left]))&#123; left++; &#125; if(left &lt; right)&#123; int tmp = arr[left]; arr[left] = arr[right]; arr[right] = tmp; &#125; &#125; &#125; public static boolean judgeCdn(int n)&#123; if(n % 2 == 0)&#123; return true; &#125; return false; &#125; public static void main(String[] args)&#123; int[] arr = new int[]&#123;1,2,3,4,5&#125;; order(arr); System.out.println(Arrays.toString(arr)); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表示数值的字符串]]></title>
    <url>%2F2019%2F10%2F31%2F%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[表示数值的字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 判断字符串是否为数字// +100 5e2 3.34235 -1E-16// 表示数值的字符串遵循 A[.[B]][e|EC] 或者 .B[e|EC]// 其中A为数值整数部分，B紧跟小数点 为小数部分，C紧跟e 或者 E 为指数部分public class A13_IsNumber &#123; public static boolean isNumeric(char[] str) &#123; if(str == null) &#123; return false; &#125; int index = 0; int eCount = 0; int pointCount = 0; for(int i = index; i &lt; str.length; i++) &#123; if(str[i] == &apos;-&apos; || str[i] == &apos;+&apos;) &#123; // // 如果第一个字符是符号，跳过 if(i == 0) &#123; continue; &#125; if(str[i - 1] != &apos;e&apos; &amp;&amp; str[i - 1] != &apos;E&apos;)&#123; return false; &#125; continue; &#125; if(str[i] == &apos;e&apos; || str[i] == &apos;E&apos;) &#123; eCount++; if(eCount &gt; 1) &#123; return false; &#125; if(i == 0 || str[i-1] &lt; 48 || str[i-1] &gt; 57 || i == str.length - 1) &#123; return false; &#125; continue; &#125; if(str[i] == &apos;.&apos;) &#123; pointCount++; if(pointCount &gt; 1) &#123; return false; &#125; continue; &#125; // 出现非数字且不是e/E则返回false（小数点和符号用continue跳过了） if ((str[i] &lt; 48 || str[i] &gt; 57) &amp;&amp; (str[i] != &apos;e&apos;) &amp;&amp; (str[i] != &apos;E&apos;)) return false; &#125; return true; &#125; public static boolean isNumeric2(char[] str) &#123; String s = String.valueOf(str); return s.matches(&quot;[+-]?[0-9]*(\\.[0-9]*)?([eE][+-]?[0-9]+)?&quot;); &#125; public static void main(String[] args) &#123; System.out.println(isNumeric(&quot;-1E-16&quot;.toCharArray())); System.out.println(isNumeric2(&quot;-1E-16&quot;.toCharArray())); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印1到最大的n位数]]></title>
    <url>%2F2019%2F10%2F30%2F%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[打印1到最大的n位数123456789101112131415161718192021222324252627282930313233343536373839// 打印1到最大的n位数，考虑大数问题public class A09_PrintMaxNNumber &#123; public static void print(int n) &#123; int[] array = new int[n]; if(n &lt;= 0) &#123; return; &#125; printArray(array, 0); &#125; // 递归 public static void printArray(int[] array, int n) &#123; for(int i = 0; i &lt; 10; i++) &#123; if(n != array.length) &#123; array[n] = i; printArray(array, n + 1); &#125; else &#123; boolean isFirstNo0 = false; for(int j = 0; j &lt; array.length; j++) &#123; if(array[j] != 0) &#123; System.out.print(array[j]); if(!isFirstNo0) &#123; isFirstNo0 = true; &#125; &#125; else &#123; if(isFirstNo0) &#123; System.out.print(array[j]); &#125; &#125; &#125; System.out.println(); return; &#125; &#125; &#125; public static void main(String[] args) &#123; print(3); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剪绳子]]></title>
    <url>%2F2019%2F10%2F29%2F%E5%89%AA%E7%BB%B3%E5%AD%90%2F</url>
    <content type="text"><![CDATA[剪绳子123456789101112131415161718192021222324252627282930313233343536// 长度为 n 的绳子，剪成 m 段，可能的最大乘积？// 长度为8，最大乘积为 2*3*3=18public class A55_MaxProductCutting &#123; // 动态规划时间O(n*n) 空间O(n) public static int maxCutting(int length)&#123; if(length &lt; 2)&#123; return 0; &#125; if(length == 2)&#123; return 1; &#125; if(length == 3)&#123; return 2; &#125; int[] products = new int[length + 1]; products[0] = 0; products[1] = 1; products[2] = 2; products[3] = 3; int max = 0; for(int i = 4; i &lt;= length; i++)&#123; max = 0; for(int j = 1; j &lt; i/2; j++)&#123; int product = products[j] * products[i-j]; if(max &lt; product)&#123; max = product; &#125; products[i] = max; &#125; &#125; return products[length]; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器人的运动范围]]></title>
    <url>%2F2019%2F10%2F28%2F%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4%2F</url>
    <content type="text"><![CDATA[机器人的运动范围1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 地上有一个m行n列的方格。// 一个机器人从坐标（0，0）的格子开始移动，它每次可以向左、右、上、下移动一个，// 但不能进入行坐标和列坐标的数位之和 大于k的格子。// 当k为18时，机器人能进入方格（35，37） 3+5+3+7=18。// 请问该机器人能够到达多少个格子？public class A54_MovingCount &#123; public static int movingCount(int threshold, int rows, int cols)&#123; if(threshold &lt; 0 || rows &lt; 0 || cols &lt; 0)&#123; return 0; &#125; boolean[] visited = new boolean[rows * cols]; for(int i = 0; i &lt; rows * cols; i++)&#123; visited[i] = false; &#125; int count = movingCountCore(threshold, rows, cols, 0, 0, visited); return count; &#125; public static int movingCountCore(int threshold, int rows, int cols, int row, int col, boolean[] visited)&#123; int count = 0; if(check(threshold, rows, cols, row, col, visited))&#123; visited[row*cols+col] = true; count = 1 + movingCountCore(threshold,rows,cols,row-1,col,visited)+ movingCountCore(threshold,rows,cols,row+1,col,visited)+ movingCountCore(threshold,rows,cols,row,col-1,visited)+ movingCountCore(threshold,rows,cols,row,col+1,visited); &#125; return count; &#125; public static int getDigitSum(int number)&#123; int sum = 0; while(number &gt; 0)&#123; sum += number % 10; number /= 10; &#125; return sum; &#125; public static boolean check(int threshold, int rows, int cols, int row, int col, boolean[] visited)&#123; if(row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols &amp;&amp; getDigitSum(row) + getDigitSum(col) &lt;= threshold &amp;&amp; !visited[row*cols+col])&#123; return true; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[------>矩阵中的路径]]></title>
    <url>%2F2019%2F10%2F27%2F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[——&gt;矩阵中的路径12]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转数组的最小数字]]></title>
    <url>%2F2019%2F10%2F26%2F%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[旋转数组的最小数字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 输入一个非递减排序数组的一个旋转，输出旋转数组的最小元素// 2-4-5-7-9// 5-7-9-2-4public class A07_MinNum &#123; // 二分法求解(寻找变化点) public static int getMin(int[] array) &#123; if(array == null || array.length ==0) &#123; return -1; &#125; if(array.length == 1 || array[array.length - 1] &gt; array[0]) &#123; return array[0]; &#125; int left = 0; int right = array.length - 1; while(left &lt;= right) &#123; int mid = (left + right) / 2; if(array[mid] &gt; array[mid+1]) &#123; return array[mid+1]; &#125; if(array[mid-1] &gt; array[mid]) &#123; return array[mid]; &#125; if(array[mid] &gt; array[0]) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; return -1; &#125; // 二分查找（最左下标） public static int getMin2(int[] array) &#123; if(array == null || array.length == 0) &#123; return -1; &#125; int left = 0; int right = array.length - 1; while(left &lt; right) &#123; int mid = (right + left) / 2; if(array[mid] &gt; array[right]) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return array[left]; &#125; // 若非递减数组中存在重复元素，求最小元素 public static int getMin3(int[] array) &#123; if(array == null || array.length == 0) &#123; return -1; &#125; int left = 0; int right = array.length - 1; while(left &lt; right) &#123; int mid = (left + right) / 2; if(array[mid] &gt; array[right]) &#123; left = mid + 1; &#125; else if(array[mid] &lt; array[right]) &#123; right = mid; &#125; else &#123; right--; &#125; &#125; return array[left]; &#125; public static void main(String[] args) &#123; int[] array = &#123;5,7,9,2,4&#125;; System.out.println(getMin(array)); System.out.println(getMin2(array)); System.out.println(getMin3(array)); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列]]></title>
    <url>%2F2019%2F10%2F25%2F%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[斐波那契数列1234567891011121314151617181920212223242526272829303132333435363738// 输入一个整数n，求费波纳茨序列第n项public class A08_Fibonacci &#123; public static int getNum(int n) &#123; int result = 0; int tmp1 = 1; int tmp2 = 0; if(n == 0) &#123; return tmp2; &#125; if(n == 1) &#123; return tmp1; &#125; for(int i = 2; i &lt;= n; i++) &#123; result = tmp1 + tmp2; tmp2 = tmp1; tmp1 = result; &#125; return result; &#125; public static int getNum2(int n)&#123; if(n &lt; 0)&#123; return 0; &#125; if(n &lt; 3)&#123; return 1; &#125; return getNum2(n-1) + getNum2(n-2); &#125; public static void main(String[] args) &#123; // 1 1 2 3 5 System.out.println(getNum2(4)); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用两个栈实现队列]]></title>
    <url>%2F2019%2F10%2F25%2F%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[用两个栈实现队列1234567891011121314151617181920212223242526272829303132// 两个栈实现队列，完成队列pop、push操作public class A06_TwoStack2Queue &#123; private static Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); private static Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;(); // push public static void push(int node) &#123; stack1.push(node); &#125; // pop public static int pop() throws Exception&#123; if(stack1.isEmpty() &amp;&amp; stack2.isEmpty()) &#123; throw new Exception(&quot;stack is empty!&quot;); &#125; if(stack2.isEmpty()) &#123; while(!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125; public static void main(String[] args) throws Exception &#123; A06_TwoStack2Queue queue = new A06_TwoStack2Queue(); queue.push(3); queue.push(2); queue.push(9); queue.push(123); System.out.println(queue.pop()); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的下一节点]]></title>
    <url>%2F2019%2F10%2F24%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[二叉树的下一节点12345678910111213141516171819202122232425// 给定一个二叉树的某个结点，请找出中序遍历顺序的下一个结点并且返回public class A53_NextTreeNode &#123; public static TreeNode getNextTreeNode(TreeNode node)&#123; if(node == null)&#123; return null; &#125; if(node.right != null)&#123; node = node.right; while(node.left != null)&#123; node = node.left; &#125; return node; &#125; while(node.parent != null)&#123; if(node.parent.left.value == node.value)&#123; return node.parent; &#125; node = node.parent; &#125; return null; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重建二叉树]]></title>
    <url>%2F2019%2F10%2F23%2F%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[重建二叉树123456789101112131415161718192021222324252627282930313233// 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树// 前序：1， 2， 4， 7， 3， 5， 6， 8// 后续：4， 7， 2， 1，5， 3， 8， 6public class A52_RebuildTree &#123; public static TreeNode rebuildTree(int[] preOrder, int[] inOrder)&#123; if(preOrder == null || inOrder == null)&#123; return null; &#125; TreeNode root = coreAgthm(preOrder, 0, preOrder.length-1, inOrder, 0, inOrder.length-1); return root; &#125; public static TreeNode coreAgthm(int[] preOrder, int startPre, int endPre, int[] inOrder, int startIn, int endIn)&#123; if(startPre &gt; endPre || startIn &gt; endIn)&#123; return null; &#125; TreeNode root = new TreeNode(preOrder[startPre]); for(int i = startIn; i &lt;= endIn; i++)&#123; if(preOrder[startPre] == inOrder[i])&#123; root.left = coreAgthm(preOrder, startPre+1, startPre+(i-startIn), inOrder, startIn, i-1); root.right = coreAgthm(preOrder, (i-startIn)+startPre+1, endPre, inOrder, i+1, endIn); &#125; &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从尾到头打印链表]]></title>
    <url>%2F2019%2F10%2F22%2F%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[从尾到头打印链表12345678910111213141516171819202122232425262728293031323334353637// 从尾到头打印节点public class A05_PrintReverseList &#123; // 栈 public static ArrayList&lt;Integer&gt; getReverseList(Node head)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while(head != null) &#123; stack.push(head.getValue()); head = head.getNext(); &#125; while(!stack.isEmpty()) &#123; list.add(stack.pop()); &#125; return list; &#125; // 递归 public static ArrayList&lt;Integer&gt; getReverseList2(Node head)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (head != null) &#123; if (head.getNext() != null) &#123; list = getReverseList2(head.getNext()); &#125; list.add(head.getValue()); &#125; return list; &#125; public static void main(String[] args) &#123; Node n1 = new Node(3, null); Node n2 = new Node(5, n1); Node n3 = new Node(7, n2); System.out.println(Arrays.toString(getReverseList(n3).toArray())); System.out.println(Arrays.toString(getReverseList2(n3).toArray())); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[替换字符串中的空格]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[替换字符串中的空格12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 替换空格public class A04_ReplaceBlank &#123; // StringBuilder public static String replaceBlank(String input) &#123; if(input == null) &#123; return null; &#125; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; input.length(); i++) &#123; if(String.valueOf(input.charAt(i)).equals(&quot; &quot;)) &#123; sb.append(&quot;%20&quot;); &#125; else &#123; sb.append(input.charAt(i)); &#125; &#125; return sb.toString(); &#125; // 从后往前复制 public static String replaceBlank2(String input) &#123; if(input == null) &#123; return null; &#125; int blankNum = 0; int length = input.length(); int newLength = 0; for(int i = 0; i &lt; input.length(); i++) &#123; if(input.charAt(i) == &apos; &apos;) &#123; blankNum++; &#125; &#125; newLength = length + blankNum * 2; char[] newChars = new char[newLength]; int index = newLength - 1; for(int i = length - 1; i &gt;= 0; i--) &#123; if(input.charAt(i) == &apos; &apos;) &#123; newChars[index--] = &apos;0&apos;; newChars[index--] = &apos;2&apos;; newChars[index--] = &apos;%&apos;; &#125; else &#123; newChars[index--] = input.charAt(i); &#125; &#125; return new String(newChars); &#125; public static void main(String[] args) &#123; String s = &quot;s df ette tg &quot;; System.out.println(&quot;one: ---&gt;&quot; + replaceBlank(s)); System.out.println(&quot;two: ---&gt;&quot; + replaceBlank2(s)); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维数组中的查找]]></title>
    <url>%2F2019%2F10%2F21%2F%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二维数组中的查找12345678910111213141516171819202122// 一个二维数组：每一行从左到右递增，每一列从上到下递增// 输入一个二维数组和一个整数，判断数组中是否含有整数public class A03_FindeNum &#123; public static boolean find(int[][] array, int target) &#123; if(array == null || array.length == 0) &#123; return false; &#125; int row = 0; int column = array[0].length - 1; while(row &lt; array.length &amp;&amp; column &gt; 0) &#123; if(array[row][column] == target) &#123; return true; &#125; if(array[row][column] &gt; target) &#123; column--; &#125; else &#123; row++; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中重复的数字]]></title>
    <url>%2F2019%2F10%2F20%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[数组中重复的数字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 0到n-1的范围内的数组中// 请找出数组中任意一个重复的数字public class A51_DuplicationInArray &#123; public static int duplicate(int[] arr)&#123; if(arr == null || arr.length == 0)&#123; return -1; &#125; for(int i = 0; i &lt; arr.length; i++)&#123; if(arr[i] &lt; 0 || arr[i] &gt; arr.length - 1)&#123; return -1; &#125; &#125; for(int i = 0; i &lt; arr.length; i++)&#123; while(arr[i] != i)&#123; if(arr[i] == arr[arr[i]])&#123; return arr[i]; &#125; else&#123; int tmp = arr[i]; arr[i] = arr[tmp]; arr[tmp] = tmp; &#125; &#125; &#125; return -1; &#125; // 不修改数组，找出重复数字，时间复杂度 0（nlogn） public static int duplicate2(int[] arr)&#123; if(arr == null || arr.length == 0)&#123; return -1; &#125; int start = 1; int end = arr.length - 1; while(end &gt;= start)&#123; int middle = ((end - start) &gt;&gt; 1) + start; int count = countRange(arr, start, middle); if(end == start)&#123; if(count &gt; 1)&#123; return start; // 重复的数字 &#125; else&#123; break; &#125; &#125; if(count &gt; (middle - start) + 1)&#123; end = middle; &#125; else&#123; start = middle + 1; &#125; &#125; return -1; &#125; public static int countRange(int[] arr, int start, int end)&#123; if(arr == null || arr.length == 0)&#123; return 0; &#125; int count = 0; for(int i = 0; i &lt; arr.length; i++)&#123; if(arr[i] &gt;= start &amp;&amp; arr[i] &lt;= end)&#123; count++; &#125; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Singleton单例模式]]></title>
    <url>%2F2019%2F10%2F19%2FSingleton%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Singleton单例模式饿汉式：线程安全、耗资源1234567class Singleton01&#123; private static final Singleton01 instance = new Singleton01(); public static Singleton01 getInstance() &#123; return instance; &#125; private Singleton01() &#123;&#125;&#125; 饿汉式：静态代码块实例对象1234567891011class Singleton02&#123; private static Singleton02 instance; static &#123; instance = new Singleton02(); &#125; public static Singleton02 getInstance() &#123; return instance; &#125; private Singleton02() &#123;&#125;&#125; 懒汉式：非线程安全12345678910class Singleton03&#123; private static Singleton03 instance; public static Singleton03 getInstance() &#123; if(null == instance) &#123; instance = new Singleton03(); &#125; return instance; &#125; private Singleton03() &#123;&#125;&#125; 懒汉式：线程安全12345678910class Singleton04&#123; private static Singleton04 instance; public synchronized static Singleton04 getInstance() &#123; if(null == instance) &#123; instance = new Singleton04(); &#125; return instance; &#125; private Singleton04() &#123;&#125;&#125; 懒汉式：线程安全、双重检查锁（同步代码块）1234567891011121314class Singleton05&#123; private static Singleton05 instance; public static Singleton05 getInstance() &#123; if(null == instance) &#123; synchronized (Singleton05.class) &#123; if(null == instance) &#123; instance = new Singleton05(); &#125; &#125; &#125; return instance; &#125; private Singleton05() &#123;&#125;&#125; 线程安全：静态内部类(推荐)12345678910class Singleton06&#123; private static Singleton06 instance; private static class SingletonHolder&#123; private static Singleton06 me = new Singleton06(); &#125; public static Singleton06 getInstance() &#123; return SingletonHolder.me; &#125; private Singleton06() &#123;&#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树中两个节点的最低公共祖先]]></title>
    <url>%2F2019%2F10%2F16%2F%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[树中两个节点的最低公共祖先123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// 树中两个节点的最低公共祖先public class A50_MinParent &#123; // 二叉搜索树 : 递归调用二叉树，查找到大于n1 小于n2的节点 public static TreeNode getMinParent(TreeNode root, TreeNode n1, TreeNode n2)&#123; if(root == null || n1 == null || n2 == null)&#123; return null; &#125; if((root.value - n1.value) * (root.value - n2.value) &lt; 0)&#123; return root; &#125; else &#123; // (root.value - n1.value) * (root.value - n2.value) &gt; 0 TreeNode tmp = (root.value &gt; n1.value &amp;&amp; root.value &gt; n2.value) ? root.left : root.right; return getMinParent(tmp, n1, n2); &#125; &#125; // 普通树，但有指向父节点的指针，类似求两单链表的第一个公共点 // 时间复杂度0（log n) 空间复杂度0（1） public static Node getMinParent2(Node n1, Node n2)&#123; if(n1 == null || n2 == null)&#123; return null; &#125; int len1 = getLen(n1); int len2 = getLen(n2); Node longNode = len1 &gt; len2 ? n1 : n2; Node shortNode = len1 &gt; len2 ? n2 : n1; int diff = Math.abs(len1 - len2); while(diff &gt; 0)&#123; diff--; longNode = longNode.getNext(); &#125; while(longNode.getValue() != shortNode.getValue())&#123; longNode = longNode.getNext(); shortNode = shortNode.getNext(); &#125; return longNode; &#125; public static int getLen(Node n)&#123; if(n == null)&#123; return 0; &#125; int len = 0; Node head = n; while(head != null)&#123; len++; head = head.getNext(); &#125; return len; &#125; // 普通树，没有父节点指针 public static TNode getMinParent(TNode root, TNode n1, TNode n2)&#123; if(root == null || n1 == null || n2 == null)&#123; return null; &#125; LinkedList&lt;TNode&gt; path1 = new LinkedList&lt;&gt;(); boolean flag1 = getPath(n1, root, path1); LinkedList&lt;TNode&gt; path2 = new LinkedList&lt;&gt;(); boolean flag2 = getPath(n2, root, path2); int sub = Math.abs(path1.size() - path2.size()); if(path1.size() &lt; path2.size())&#123; LinkedList tmp = path1; path1 = path2; path2 = tmp; &#125; int index = 0; while(index != path2.size() - 1)&#123; if(((TNode) path1.get(index+sub)).value == ((TNode)path2.get(index)).value)&#123; return (TNode)path1.get(index); &#125; else&#123; index++; &#125; &#125; return null; &#125; public static boolean getPath(TNode node, TNode currentNode, LinkedList&lt;TNode&gt; path)&#123; if(node.value == currentNode.value)&#123; return true; &#125; path.push(currentNode); boolean found = false; TNode[] childs = node.childs; if(childs != null &amp;&amp; childs.length &gt; 0)&#123; for(int i = 0; i &lt; childs.length; i++)&#123; if(found)&#123; break; &#125; else&#123; found = getPath(node,childs[i], path); &#125; &#125; &#125; if(!found)&#123; path.pop(); &#125; return found; &#125;&#125;class TNode&#123; char value; TNode childs[]; TNode(char val)&#123; this.value = val; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实战Java高并发程序设计]]></title>
    <url>%2F2019%2F10%2F16%2F%E5%AE%9E%E6%88%98Java%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[实战Java高并发程序设计参考 github笔记第1章 走入并行世界1.1 何去何从的并行计算 1.1.1 忘掉那该死的并行 1.1.2 可怕的现实：摩尔定律的失效 1.1.3 柳暗花明：不断地前进 1.1.4 光明或是黑暗 1.2 你必须知道的几个概念 1.2.1 同步（Synchronous）和异步（Asynchronous） 1.2.2 并发（Concurrency）和并行（Parallelism） 1.2.3 临界区 1.2.4 阻塞（Blocking）和非阻塞（Non-Blocking） 1.2.5 死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock） 1.3 并发级别 1.3.1 阻塞（Blocking） 1.3.2 无饥饿（Starvation-Free） 1.3.3 无障碍（Obstruction-Free） 1.3.4 无锁（Lock-Free） 1.3.5 无等待（Wait-Free） 1.4 有关并行的两个重要定律 1.4.1 Amdahl定律 1.4.2 Gustafson定律 1.4.3 Amdahl定律和Gustafson定律是否相互矛盾 1.5 回到Java：JMM 1.5.1 原子性（Atomicity） 1.5.2 可见性（Visibility） 1.5.3 有序性（Ordering） 1.5.4 哪些指令不能重排：Happen-Before规则 1.6 参考文献 第2章 Java并行程序基础2.1 有关线程你必须知道的事 2.2 初始线程：线程的基本操作 2.2.1 新建线程 2.2.2 终止线程 2.2.3 线程中断 2.2.4 等待（wait）和通知（notify） 2.2.5 挂起（suspend）和继续执行（resume）线程 2.2.6 等待线程结束（join）和谦让（yield） 2.3 volatile与Java内存模型（JMM） 2.4 分门别类的管理：线程组 2.5 驻守后台：守护线程（Daemon） 2.6 先干重要的事：线程优先级 2.7 线程安全的概念与synchronized 2.8 程序中的幽灵：隐蔽的错误 2.8.1 无提示的错误案例 2.8.2 并发下的ArrayList 2.8.3 并发下诡异的HashMap 2.8.4 初学者常见问题：错误的加锁 2.9 参考文献第3章 JDK并发包3.1 多线程的团队协作：同步控制 3.1.1 synchronized的功能扩展：重入锁 3.1.2 重入锁的好搭档：Condition条件 3.1.3 允许多个线程同时访问：信号量（Semaphore） 3.1.4 ReadWriteLock读写锁 3.1.5 倒计时器：CountDownLatch 3.1.6 循环栅栏：CyclicBarrier 3.1.7 线程阻塞工具类：LockSupport 3.2 线程复用：线程池 3.2.1 什么是线程池 3.2.2 不要重复发明轮子：JDK对线程池的支持 3.2.3 刨根究底：核心线程池的内部实现 3.2.4 超负载了怎么办：拒绝策略 3.2.5 自定义线程创建：ThreadFactory 3.2.6 我的应用我做主：扩展线程池 3.2.7 合理的选择：优化线程池线程数量 3.2.8 堆栈去哪里了：在线程池中寻找堆栈 3.2.9 分而治之：Fork/Join框架 3.3 不要重复发明轮子：JDK的并发容器 3.3.1 超好用的工具类：并发集合简介 3.3.2 线程安全的HashMap 3.3.3 有关List的线程安全 3.3.4 高效读写的队列：深度剖析ConcurrentLinkedQueue 3.3.5 高效读取：不变模式下的CopyOnWriteArrayList 3.3.6 数据共享通道：BlockingQueue 3.3.7 随机数据结构：跳表（SkipList） 3.4 参考资料第4章 锁的优化及注意事项4.1 有助于提高&quot;锁&quot;性能的几点建议 4.1.1 减小锁持有时间 4.1.2 减小锁粒度 4.1.3 读写分离锁来替换独占锁 4.1.4 锁分离 4.1.5 锁粗化 4.2 Java虚拟机对锁优化所做的努力 4.2.1 锁偏向 4.2.2 轻量级锁 4.2.3 自旋锁 4.2.4 锁消除 4.3 人手一支笔：ThreadLocal 4.3.1 ThreadLocal的简单使用 4.3.2 ThreadLocal的实现原理 4.3.3 对性能有何帮助 4.4 无锁 4.4.1 与众不同的并发策略：比较交换（CAS） 4.4.2 无锁的线程安全整数：AtomicInteger 4.4.3 Java中的指针：Unsafe类 4.4.4 无锁的对象引用：AtomicReference 4.4.5 带有时间戳的对象引用：AtomicStampedReference 4.4.6 数组也能无锁：AtomicIntegerArray 4.4.7 让普通变量也享受原子操作：AtomicIntegerFieldUpdater 4.4.8 挑战无锁算法：无锁的Vector实现 4.4.9 让线程之间互相帮助：细看SynchronousQueue的实现 4.5 有关死锁的问题 4.6 参考文献第5章 并行模式与算法5.1 探讨单例模式 5.2 不变模式 5.3 生产者-消费者模式 5.4 高性能的生产者-消费者：无锁的实现 5.4.1 无锁的缓存框架：Disruptor 5.4.2 用Disruptor实现生产者-消费者案例 5.4.3 提高消费者的响应时间：选择合适的策略 5.4.4 CPU Cache的优化：解决伪共享问题 5.5 Future模式 5.5.1 Future模式的主要角色 5.5.2 Future模式的简单实现 5.5.3 JDK中的Future模式 5.6 并行流水线 5.7 并行搜索 5.8 并行排序 5.8.1 分离数据相关性：奇偶交换排序 5.8.2 改进的插入排序：希尔排序 5.9 并行算法：矩阵乘法 5.10 准备好了再通知我：网络NIO 5.10.1 基于Socket的服务端的多线程模式 5.10.2 使用NIO进行网络编程 5.10.3 使用NIO来实现客户端 5.11 读完了再通知我：AIO 5.11.1 AIO EchoServer的实现 5.11.2 AIO Echo客户端实现 5.12 参考文献第6章 Java8与并发 6.1 Java 8的函数式编程简介 6.1.1 函数作为一等公民 6.1.2 无副作用 6.1.3 申明式的（Declarative） 6.1.4 不变的对象 6.1.5 易于并行 6.1.6 更少的代码 6.2 函数式编程基础 6.2.1 FunctionalInterface注释 6.2.2 接口默认方法 6.2.3 lambda表达式 6.2.4 方法引用 6.3 一步一步走入函数式编程 6.4 并行流与并行排序 6.4.1 使用并行流过滤数据 6.4.2 从集合得到并行流 6.4.3 并行排序 6.5 增强的Future：CompletableFuture 6.5.1 完成了就通知我 6.5.2 异步执行任务 6.5.3 流式调用 6.5.4 CompletableFuture中的异常处理 6.5.5 组合多个CompletableFuture 6.6 读写锁的改进：StampedLock 6.6.1 StampedLock使用示例 6.6.2 StampedLock的小陷阱 6.6.3 有关StampedLock的实现思想 6.7 原子类的增强 6.7.1 更快的原子类：LongAdder 6.7.2 LongAdder的功能增强版：LongAccumulator 6.8 参考文献第7章 使用Akka构建高并发程序7.1 新并发模型：Actor 7.2 Akka之HelloWorld 7.3 有关消息投递的一些说明 7.4 Actor的生命周期 7.5 监督策略 7.6 选择Actor 7.7 消息收件箱（Inbox） 7.8 消息路由 7.9 Actor的内置状态转换 7.10 询问模式：Actor中的Future 7.11 多个Actor同时修改数据：Agent 7.12 像数据库一样操作内存数据：软件事务内存]]></content>
      <categories>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将字符串转换为整数]]></title>
    <url>%2F2019%2F10%2F15%2F%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[将字符串转换为整数123456789101112131415161718192021222324252627282930313233// 将字符串转换为整数public class A49_StrToInt &#123; public static int strToInt(String str)&#123; if(str == null || str.length() == 0)&#123; return 0; &#125; int mark = 1; int number = 0; int i = 0; char[] chars = str.toCharArray(); if(chars[0] == &apos;-&apos;)&#123; mark = -1; i++; &#125; if(chars[0] == &apos;+&apos;)&#123; i++; &#125; for(; i &lt; chars.length; i++)&#123; if(chars[i] &lt; 48 || chars[i] &gt; 57)&#123; return 0; &#125; number = number * 10 + chars[i] - 48; &#125; return mark * number; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-->构建乘积数组]]></title>
    <url>%2F2019%2F10%2F15%2F%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[–&gt;构建乘积数组123456789101112131415161718public static int[] multiply(int[] A) &#123; int length = A.length; int[] B = new int[length]; if (length != 0) &#123; B[0] = 1; //计算下三角连乘 for (int i = 1; i &lt; length; i++) &#123; B[i] = B[i - 1] * A[i - 1]; &#125; int temp = 1; //计算上三角连乘 for (int j = length - 2; j &gt;= 0; j--) &#123; temp *= A[j + 1]; B[j] *= temp; &#125; &#125; return B; &#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-->不用加减乘除做加法]]></title>
    <url>%2F2019%2F10%2F15%2F%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[-&gt;不用加减乘除做加法1234567891011// 不用加减乘除做加法：+、-、*、÷public class A48_Add &#123; public static int add(int num1,int num2) &#123; while (num2 != 0) &#123; int temp = num1 ^ num2; num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = temp; &#125; return num1; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1+2+3+...+n的和]]></title>
    <url>%2F2019%2F10%2F14%2F1-2-3-n%E7%9A%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1+2+3+…+n的和12345678910111213141516171819202122// 求1+2+3+…+n// 要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:Cpublic class A47_Calculate &#123; // 递归 public static int sum(int n)&#123; int sum = n; boolean flag = (n &gt; 0) &amp;&amp; ((sum += sum(n - 1)) &gt; 0); return sum; &#125; // 递归 + 全局变量 private static int s = 0; public static int calSum(int n)&#123; calSum1(n); return s; &#125; private static boolean calSum1(int n)&#123; s += n; return (n &gt; 0) &amp;&amp; calSum1(n - 1); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[圆圈中最后剩下的数字]]></title>
    <url>%2F2019%2F10%2F14%2F%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[圆圈中最后剩下的数字12345678910111213141516171819202122232425262728293031323334// 0,1...n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字// 求圆圈中最后剩下的数字public class A45_LastRemainRing &#123; // 借助链表 public static int lastRemainRing(int n, int m)&#123; LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;(); int index = 0; for(int i = 0; i &lt; n; i++)&#123; list.add(i); &#125; while(list.size() &gt; 1)&#123; index = (index + m - 1) % list.size(); list.remove(index); &#125; return list.size() == 1 ? list.get(0) : -1; &#125; // 借助公式 public static int lastRemainRing2(int n, int m)&#123; if(n &lt; 1 || m &lt; 1)&#123; return -1; &#125; int last = 0; for(int i = 2; i &lt;= n; i++)&#123; // i个人时删除数的索引等于i-1个人时删除数的索引+k(再对i取余) last = (last + m) % i; &#125; return last; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[------->扑克牌中的顺子]]></title>
    <url>%2F2019%2F10%2F13%2F%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90%2F</url>
    <content type="text"><![CDATA[——-&gt;扑克牌中的顺子]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[------->n个骰子的点数]]></title>
    <url>%2F2019%2F10%2F13%2Fn%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[——-&gt;n个骰子的点数]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[------>队列的最大值]]></title>
    <url>%2F2019%2F10%2F12%2F%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[——&gt;队列的最大值]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻转字符串]]></title>
    <url>%2F2019%2F10%2F10%2F%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[翻转字符串1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 翻转字符串public class A44_Reverse &#123; // 翻转单词顺序 public static void reverseStr(String str)&#123; if(str == null || str.length() &lt; 1)&#123; return; &#125; String[] tmp = str.split(&quot; &quot;); for(int i = 0; i &lt; (tmp.length + 1)/2; i++)&#123; String strTmp = tmp[i]; tmp[i] = tmp[tmp.length - 1 - i]; tmp[tmp.length - 1 - i] = strTmp; &#125; for(int i = 0; i &lt; tmp.length; i++)&#123; System.out.print(tmp[i] + &quot; &quot;); &#125; &#125; public static String reverse(String str)&#123; StringBuilder sb = new StringBuilder(); for(int i = str.length() - 1; i &gt;= 0; i--)&#123; sb.append(str.substring(i, i+1)); &#125; return sb.toString(); &#125; // 字符串的左旋转 public static String leftRotateString(String sentence, int index)&#123; if(sentence == null || index &gt; sentence.length() || index &lt; 0)&#123; return null; &#125; String sentenceReverse = reverse(sentence); String[] splitStr = &#123;sentenceReverse.substring(0, sentence.length()- index), sentenceReverse.substring(sentence.length() - index, sentence.length())&#125;; StringBuilder sb = new StringBuilder(); for(String s : splitStr)&#123; sb.append(reverse(s)); &#125; return sb.toString(); &#125; public static void main(String[] args)&#123; reverse(&quot; I am a student.&quot;); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为s的连续正数序列]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[和为s的连续正数序列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class A43_FindNumbersWithSum &#123; // 递增数组中，和为s的数字 public static ArrayList&lt;Integer&gt; findNumbersWithSum(int[] arr, int sum)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int length = arr.length; int left = 0; int right = length - 1; while(left &lt; right)&#123; if(arr[left] + arr[right] == sum)&#123; list.add(arr[left]); list.add(arr[right]); break; &#125; else if(arr[left] + arr[right] &lt; sum)&#123; left++; &#125; else if(arr[left] + arr[right] &gt; sum)&#123; right--; &#125; &#125; return list; &#125; // 和为s的连续正数序列 public static void findContinuousSequence(int s)&#123; if(s &lt; 4)&#123; return ; &#125; int small = 1; int big = 2; int curSum = small + big; while(small &lt; (s+1) / 2)&#123; if(curSum == s)&#123; for(int i = small; i &lt;= big; i++)&#123; System.out.print(i+&quot; &quot;); &#125; System.out.println(&quot;&quot;); curSum -= small; small++; &#125; else if(curSum &gt; s)&#123; curSum -= small; small++; &#125; else&#123; big++; curSum += big; &#125; &#125; &#125; public static void main(String[] args)&#123; findContinuousSequence(15); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为s的两个数字]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[和为s的两个数字12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class A43_FindNumbersWithSum &#123; // 递增数组中，和为s的数字 public static ArrayList&lt;Integer&gt; findNumbersWithSum(int[] arr, int sum)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int length = arr.length; int left = 0; int right = length - 1; while(left &lt; right)&#123; if(arr[left] + arr[right] == sum)&#123; list.add(arr[left]); list.add(arr[right]); break; &#125; else if(arr[left] + arr[right] &lt; sum)&#123; left++; &#125; else if(arr[left] + arr[right] &gt; sum)&#123; right--; &#125; &#125; return list; &#125; // 和为s的连续正数序列 public static void findContinuousSequence(int s)&#123; if(s &lt; 4)&#123; return ; &#125; int small = 1; int big = 2; int curSum = small + big; while(small &lt; (s+1) / 2)&#123; if(curSum == s)&#123; for(int i = small; i &lt;= big; i++)&#123; System.out.print(i+&quot; &quot;); &#125; System.out.println(&quot;&quot;); curSum -= small; small++; &#125; else if(curSum &gt; s)&#123; curSum -= small; small++; &#125; else&#123; big++; curSum += big; &#125; &#125; &#125; public static void main(String[] args)&#123; findContinuousSequence(15); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[----->数组中唯一只出现一次的数字]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%94%AF%E4%B8%80%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[—–&gt;数组中唯一只出现一次的数字]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-------]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%EF%BC%8C%E8%80%8C%E5%85%B6%E4%BB%96%E6%95%B0%E9%83%BD%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[——-&lt;数组中只出现一次的两个数，而其他数都出现两]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡二叉树123456789101112131415161718192021222324// 判断是否为平衡二叉树public class A42_BalancedTree &#123; // 求深度 public static int getDepth(TreeNode node)&#123; if(node == null)&#123; return 0; &#125; return Math.max(getDepth(node.left), getDepth(node.right)) + 1; &#125; // 判断 public static boolean isBalanced(TreeNode root)&#123; if(root == null)&#123; return true; &#125; if(Math.abs(getDepth(root.left) - getDepth(root.right)) &gt; 1)&#123; return false; &#125; else&#123; return isBalanced(root.left) &amp;&amp; isBalanced(root.right); &#125; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的深度]]></title>
    <url>%2F2019%2F10%2F07%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[二叉树的深度12345678910111213// 二叉树的深度public class A41_TreeDepth &#123; public static int treeDepth(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; int nLeft = treeDepth(root.left); int nRight = treeDepth(root.right); return (nLeft &gt; nRight) ? (nLeft + 1) : (nRight + 1); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树中的第K大的节点]]></title>
    <url>%2F2019%2F10%2F07%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E7%AC%ACK%E5%A4%A7%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[二叉搜索树中的第K大的节点12345678910111213141516171819202122232425262728293031public class A40_KthNode &#123; public static TreeNode findKth(TreeNode root, Tmp k)&#123; if(k.val &lt; 1 || root == null)&#123; return null; &#125; TreeNode target = null; if(root.left != null)&#123; target = findKth(root.left, k); &#125; if(target == null)&#123; if(k.val == 1)&#123; target = root; &#125; k.val--; &#125; if(target == null &amp;&amp; root.right != null)&#123; target = findKth(root.right, k); &#125; return target; &#125;&#125;class Tmp&#123; public int val; Tmp(int val)&#123; this.val = val; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中数值和下标相等的元素]]></title>
    <url>%2F2019%2F10%2F07%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E7%9B%B8%E7%AD%89%E7%9A%84%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[数组中数值和下标相等的元素1234567891011121314151617181920212223// 递增数组中，数值和下标相等的元素public class A39_GetNumberSameAsIndex &#123; public static int getNumberSameAsIndex(int[] arr)&#123; if(arr == null || arr.length == 0)&#123; return -1; &#125; int left = 0; int right = arr.length - 1; while(left &lt; right)&#123; int middle = (left + right) &gt;&gt; 1; if(arr[middle] == middle)&#123; return middle; &#125; else if(arr[middle] &lt; middle)&#123; left = middle + 1; &#125; else&#123; right = middle - 1; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[0~n-1中缺失的数字]]></title>
    <url>%2F2019%2F10%2F07%2F0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[0~n-1中缺失的数字123456789101112131415161718192021222324252627// 已排序的数组中，0 ~ n-1中缺失的数字public class A38_GetMissingNumber &#123; public static int getMissingNumber(int[] arr)&#123; if(arr == null || arr.length == 0)&#123; return -1; &#125; int left = 0; int right = arr.length - 1; while(left &lt; right)&#123; int middle = (left + right) &gt;&gt; 1; if(arr[middle] != middle)&#123; if(middle == 0 || arr[middle-1] == middle - 1)&#123; return middle; &#125; right = middle - 1; &#125; else&#123; left = middle + 1; &#125; &#125; if(left == right)&#123; return arr.length; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字在排序数组中出现的次数]]></title>
    <url>%2F2019%2F10%2F06%2F%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[数字在排序数组中出现的次数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 统计一个数字在排序数组中出现的次数// 二分思想public class A37_GetNumberOfK &#123; // 找出第一个K的位置 public static int getFirstK(int[] nums, int k, int start, int end)&#123; if(start &gt; end)&#123; return -1; &#125; int middleIndex = (start + end) / 2; int middleData = nums[middleIndex]; if(middleData == k)&#123; // 找出第一个位置k的终止条件：要么middleIndex=0; // 要么middleIndex &gt; 0但是middleIndex-1处的位置不等于k if((middleIndex &gt; 0 &amp;&amp; nums[middleIndex-1] != k) || middleIndex == 0)&#123; return middleIndex; &#125; else&#123; end = middleIndex - 1; &#125; &#125; else if(middleData &gt; k)&#123; end = middleIndex - 1; &#125; else &#123; start = middleIndex + 1; &#125; return getFirstK(nums, k, start, end); &#125; // 找出最后一个k位置 public static int getLastK(int[] nums, int k, int start, int end)&#123; if(start &gt; end)&#123; return -1; &#125; int middleIndex = (start + end) / 2; int middleData = nums[middleIndex]; if(middleData == k)&#123; if((middleIndex &lt; nums.length &amp;&amp; nums[middleIndex + 1] != k) || middleIndex == nums.length -1)&#123; return middleIndex; &#125; else&#123; start = middleIndex + 1; &#125; &#125; else if(middleData &gt; k)&#123; start = middleIndex + 1; &#125; else&#123; end = middleIndex - 1; &#125; return getLastK(nums, k, start, end); &#125; public static int getNumOfK(int[] nums, int k)&#123; int number = 0; int len = nums.length; if(nums != null &amp;&amp; len &gt; 0)&#123; int firstK = getFirstK(nums, k, 0, len - 1); int lastK = getLastK(nums, k, 0, len - 1); if(firstK &gt; -1 &amp;&amp; lastK &gt; -1)&#123; number = lastK - firstK + 1; &#125; &#125; return number; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个链表的第一个公共节点]]></title>
    <url>%2F2019%2F10%2F06%2F%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[两个链表的第一个公共节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 求两个单向链表的第一个公共节点public class A36_FindFirstCommonNode &#123; public static Node findFirstCommond(Node pHead1, Node pHead2)&#123; if(pHead1 == null || pHead2 == null)&#123; return null; &#125; Node p1 = pHead1; Node p2 = pHead2; int lth1 = getListNodeLth(p1); int lth2 = getListNodeLth(p2); int diff = 0; if(lth1 &gt; lth2)&#123; diff = lth1 - lth2; while(diff-- &gt; 0)&#123; p1 = p1.getNext(); &#125; &#125; else&#123; diff = lth2 - lth1; while(diff-- &gt; 0)&#123; p2 = p2.getNext(); &#125; &#125; while(p1 != null &amp;&amp; p2 != null)&#123; if(p1.getValue() == p2.getValue())&#123; return p1; &#125; p1 = p1.getNext(); p2 = p2.getNext(); &#125; return null; &#125; public static int getListNodeLth(Node node)&#123; int result = 0; if(node == null)&#123; return 0; &#125; Node root = node; while(root != null)&#123; root = root.getNext(); result++; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中逆序对的个数]]></title>
    <url>%2F2019%2F09%2F29%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[数组中逆序对的个数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 数组中的两个数字如果前面一个数字大于后面一个数字// 则这两个数字组成一个逆序对，输入一个数组，求逆序对的总数public class A35_InversePairs &#123; private int count = 0; public int inversePair(int[] arr)&#123; if(arr == null)&#123; return 0; &#125; mergeSort(arr, 0, arr.length - 1); return count; &#125; public void mergeSort(int[] arr, int left, int right)&#123; int mid = (left + right) / 2; if(left &lt; right)&#123; mergeSort(arr, left, mid); mergeSort(arr, mid, right); merge(arr, left, mid, right); &#125; &#125; public void merge(int[] arr, int left, int mid, int right)&#123; int[] data = new int[right - left + 1]; int l = left; int c = 0; int index = mid + 1; while(left &lt; mid &amp;&amp; index &lt; right)&#123; if(arr[left] &lt; arr[index])&#123; data[c++] = arr[left++]; &#125; else&#123; count += index - left; // 防止数值过大而求余 count %= 1000000007; data[c++] = arr[index++]; &#125; &#125; while(left &lt;= mid)&#123; data[c++] = arr[left++]; &#125; while(index &lt;= right)&#123; data[c++] = arr[index++]; &#125; for(int i = 0; i &lt; data.length; i++)&#123; arr[i + l] = data[i]; &#125; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符流中第一个不重复的字符]]></title>
    <url>%2F2019%2F09%2F29%2F%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[字符流中第一个不重复的字符1234567891011121314151617181920212223// 实现一个函数用来找出字符流中第一个只出现一次的字符public class A34_FirstAppearingOnce &#123; static int[] chars = new int[256]; static StringBuilder sb = new StringBuilder(); public static void insertChars(char[] insertChars)&#123; for(char ch : insertChars)&#123; sb.append(ch); chars[ch]++; &#125; &#125; public static char getFirst()&#123; char[] str = sb.toString().toCharArray(); for(char c : str)&#123; if(chars[c] == 1)&#123; return c; &#125; &#125; return &apos; &apos;; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个出现一次的字符]]></title>
    <url>%2F2019%2F09%2F28%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[第一个出现一次的字符1234567891011121314151617181920212223242526272829// 获取第一个只出现一次的字符的下标public class A33_FirstNotRepeating &#123; public static int getFirstNotRepeating(String str)&#123; if(str == null)&#123; return -1; &#125; char[] strChar = str.toCharArray(); LinkedHashMap&lt;Character, Integer&gt; hash = new LinkedHashMap&lt;&gt;(); for(char item : strChar)&#123; if(hash.containsKey(item))&#123; hash.put(item, hash.get(item) + 1); &#125; else&#123; hash.put(item, 1); &#125; &#125; int i = 0; for(Map.Entry&lt;Character, Integer&gt; entry : hash.entrySet())&#123; if(entry.getValue() == 1)&#123; System.out.println(&quot;第一次出现：&quot; + entry.getKey()); return i; &#125; i++; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[------->第n个丑数]]></title>
    <url>%2F2019%2F09%2F28%2F%E7%AC%ACn%E4%B8%AA%E4%B8%91%E6%95%B0%2F</url>
    <content type="text"><![CDATA[——-&gt;第n个丑数]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[------->最长不含重复字符的子字符串]]></title>
    <url>%2F2019%2F09%2F27%2F%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[——-&gt;最长不含重复字符的子字符串]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[礼物的最大价值]]></title>
    <url>%2F2019%2F09%2F26%2F%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[礼物的最大价值123456789101112131415161718192021222324252627282930// 在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）// 从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格直到到达棋盘的右下角。// 给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？public class A32_GreatestGift &#123; public static int getMaxValue(int[][] arr)&#123; if(arr == null || arr.length == 0)&#123; return 0; &#125; int rows = arr.length; int cols = arr[0].length; int[][] maxValue = new int[rows][cols]; for(int i = 0; i &lt; rows; i++)&#123; for(int j = 0; j &lt; cols; j++)&#123; int left = 0; int up = 0; if(i &gt; 0)&#123; up = maxValue[i-1][j]; &#125; if(j &gt; 0)&#123; left = maxValue[i][j-1]; &#125; maxValue[i][j] = Math.max(up, left) + arr[i][j]; &#125; &#125; return maxValue[rows-1][cols-1]; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F24%2F%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[title: ——-&gt;把数字翻译成字符串tags: algorithmcategories: sword offerdate: 2019-09-24 21:33:23 ——-&gt;把数字翻译成字符串]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java并发知识图谱]]></title>
    <url>%2F2019%2F09%2F23%2FJava%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[Java并发知识图谱]]></content>
      <categories>
        <category>java</category>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把数组中的数排成一个最小的数]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%8A%8A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8E%92%E6%88%90%E4%B8%80%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[把数组中的数排成一个最小的数123456789101112131415161718// 输入一个正整数数组，把数组里所有数字拼接起来排成一个数// 打印出能拼接出的所有数字中的最小的一个。public class A31_PrintMinNumber &#123; public static String printMinNumber(int[] num)&#123; if(num == null || num.length == 0)&#123; return &quot;&quot;; &#125; int len = num.length; StringBuilder sb = new StringBuilder(); Arrays.sort(num); for(int i = 0; i &lt; len; i++)&#123; sb.append(num[i]); &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[--------->从1到整数n中1出现的次数]]></title>
    <url>%2F2019%2F09%2F23%2F%E4%BB%8E1%E5%88%B0%E6%95%B4%E6%95%B0n%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[———&gt;从1到整数n中1出现的次数]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续子数组的最大和]]></title>
    <url>%2F2019%2F09%2F22%2F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[连续子数组的最大和123456789101112131415161718192021222324252627282930// 数组中一个或连续的多个整数组成一个子数组，求连续子数组的最大和public class A30_FindGreatestSum &#123; public static int findGreateSum(int[] arr)&#123; if(arr == null || arr.length &lt; 1)&#123; throw new RuntimeException(&quot;Array must contain a element&quot;); &#125; int max = Integer.MIN_VALUE; int curMax = 0; for(int i : arr)&#123; if(curMax &lt; 0)&#123; curMax = i; &#125; else&#123; curMax += i; &#125; max = Math.max(max, curMax); &#125; return max; &#125; public static void main(String[] args) &#123; int[] data = &#123;1, -2, 3, 10, -4, 7, 2, -5&#125;; int[] data2 = &#123;-2, -8, -1, -5, -9&#125;; int[] data3 = &#123;2, 8, 1, 5, 9&#125;; System.out.println(findGreateSum(data)); System.out.println(findGreateSum(data2)); System.out.println(findGreateSum(data3)); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[------->数据流中的中位数]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[——-&gt;数据流中的中位数]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找出其中最小的k个数]]></title>
    <url>%2F2019%2F09%2F19%2F%E6%89%BE%E5%87%BA%E5%85%B6%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[找出其中最小的k个数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 找出其中最小的k个数public class A29_GetLeastNumbers &#123; public static int partition(int[] arr, int left, int right)&#123; if(arr == null || arr.length == 0 || left &lt; 0 || right &lt; 0)&#123; return -1; &#125; int result = arr[left]; if(left &gt; right)&#123; return -1; &#125; while(left &gt; right)&#123; while(left &lt; right &amp;&amp; arr[right] &gt;= result)&#123; right--; &#125; arr[left] = arr[right]; while(left &lt; right &amp;&amp; arr[left] &lt;= result)&#123; left++; &#125; arr[right] = arr[left]; &#125; arr[left] = result; return left; &#125; // O(n)的算法，只有当我们可以修改输入的数组时可用 public static int[] getLeastNum(int[] input, int k)&#123; if(input == null || input.length == 0 || k &lt;0)&#123; return null; &#125; int[] output = new int[k]; int start = 0; int end = input.length - 1; int index = partition(input, start, end); while(index != k-1)&#123; if(index &lt; k-1)&#123; end = index - 1; &#125; else&#123; start = index + 1; &#125; index = partition(input, start, end); &#125; for(int i = 0; i &lt; k; i++)&#123; output[i] = input[i]; &#125; return output; &#125; // O(nlogk)的算法，特别适用处理海量数据&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中出现次数超过一半的数字]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[数组中出现次数超过一半的数字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字public class A28_OverHalfInArray &#123; // 如果将这个数组排序，那么排序后出现在数组中间的数字就是那个出现次数超过一半的数字， // 这个数字在统计学上被称为中位数 // 比选中的数字小的数字排在该数字的左边， // 选中的大的数字排在该数字的右边，如果这个选中的数字的下标刚好是n/2,则这个数字就是中位数 public static int partition(int[] arr, int low, int high)&#123; // 基准数 int tmp = arr[low]; while(low &lt; high)&#123; while(arr[high] &gt;= tmp &amp;&amp; low &lt; high)&#123; high--; &#125; if(low &lt; high)&#123; arr[low] = arr[high]; low++; &#125; while(arr[low] &lt;= tmp &amp;&amp; low &lt; high)&#123; low++; &#125; if(low &lt; high)&#123; arr[high] = arr[low]; high--; &#125; &#125; arr[low] = tmp; return low; &#125; public static int overHalfNum(int[] arr)&#123; if(arr == null || arr.length == 0)&#123; throw new RuntimeException(&quot;输入参数有误&quot;); &#125; if(arr.length == 1)&#123; return arr[0]; &#125; int mid = arr.length / 2; int low = 0; int high = arr.length - 1; int index = partition(arr, low, high); while(index != mid)&#123; if(index &gt; mid)&#123; high = index - 1; &#125; else&#123; low = index + 1; &#125; index = partition(arr, low, high); &#125; int result = arr[index]; // 判断中间数是否超过数组长度的一半 int count = 0; for(int i = 0; i &lt; arr.length; i++)&#123; if(arr[i] == result)&#123; count++; &#125; &#125; if(count &lt;= mid)&#123; throw new RuntimeException(&quot;出现次数少于数组长度的一半&quot;); &#125; return result; &#125; // 在遍历数组的时候保存两个值，一个是数组中的一个数字，一个是该数字出现的次数 // 当我们遍历下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加一 // 如果和我们之间保存的数字不同，则次数减一。当次数为0时，需要保存下一个数字，并将次数设置为1 public static int func2(int[] arr)&#123; if(arr == null || arr.length == 0)&#123; throw new RuntimeException(&quot;入参有误&quot;); &#125; int result = arr[0]; int times = 1; for(int i = 1; i &lt; arr.length; i++)&#123; if(times == 0)&#123; result = arr[i]; &#125; else if(arr[i] == result)&#123; times++; &#125; else&#123; times--; &#125; &#125; // 判断数组中的数字是否超过半数 times = 0; for(int i = 0; i &lt; arr.length; i++)&#123; if(arr[i] == result)&#123; times++; &#125; &#125; if(times &lt;= arr.length / 2)&#123; throw new RuntimeException(&quot;次数没有超过一半&quot;); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[----------->打印出字符串中字符的所有排列]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%89%93%E5%8D%B0%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%AD%97%E7%AC%A6%E7%9A%84%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[———–&gt;打印出字符串中字符的所有排列]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的序列化与反序列化]]></title>
    <url>%2F2019%2F09%2F11%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[二叉树的序列化与反序列化123456789101112131415161718192021222324252627282930313233343536// 二叉树的序列化和反序列化public class A27_Serializer &#123; // 序列化 ：前序遍历 public static String serialize(TreeNode root)&#123; StringBuffer sb = new StringBuffer(); if(root == null)&#123; sb.append(&quot;#,&quot;); return sb.toString(); &#125; sb.append(root.value + &quot;,&quot;); sb.append(serialize(root.left)); sb.append(serialize(root.right)); return sb.toString(); &#125; private static int index = -1; public static TreeNode deserialize(String str)&#123; index++; String[] strArray = str.split(&quot;,&quot;); int len = strArray.length; TreeNode node = null; if(index &gt;= len)&#123; return null; &#125; if(!strArray[index].equals(&quot;#&quot;))&#123; node = new TreeNode(Integer.valueOf(strArray[index])); node.left = deserialize(str); node.right = deserialize(str); &#125; return node; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-------->二叉搜索树转换为双向链表]]></title>
    <url>%2F2019%2F09%2F11%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[——–&gt;二叉搜索树转换为双向链表]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-------->复杂链表的复制]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[——–&gt;复杂链表的复制]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LRUCache java]]></title>
    <url>%2F2019%2F09%2F09%2FLRUCache-java%2F</url>
    <content type="text"><![CDATA[LRUCache java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137public class LRUCache &#123; Node head; Node tail; HashMap&lt;Integer, Node&gt; map = null; int cap = 0; public LRUCache(int capacity)&#123; this.cap = capacity; &#125; private void removeNode(Node n)&#123; if(n.pre != null)&#123; n.pre.next = n.next; &#125; else&#123; head = n.next; &#125; if(n.next != null)&#123; n.next.pre = n.pre; &#125; else&#123; tail = n.pre; &#125; &#125; private void offerNode(Node n)&#123; if(tail != null)&#123; tail.next = n; &#125; n.pre = tail; n.next = null; tail = n; if(head == null)&#123; head = tail; &#125; &#125; public int get(int key)&#123; if(map.get(key) == null)&#123; return -1; &#125; Node t = map.get(key); removeNode(t); offerNode(t); return t.value; &#125; public void put(int key, int value)&#123; if(map.containsKey(key))&#123; Node t = map.get(key); t.value = value; removeNode(t); offerNode(t); &#125; else&#123; if(map.size() &gt;= cap)&#123; map.remove(head.key); removeNode(head); &#125; Node node = new Node(key, value); offerNode(node); map.put(key, node); &#125; &#125; public class Node&#123; int key; int value; Node pre; Node next; public Node(int key, int value)&#123; this.value = value; this.key = key; &#125; &#125;&#125;class LRUCache2&#123; static Deque&lt;Integer&gt; dq; static HashSet&lt;Integer&gt; map; static int size; LRUCache2(int n)&#123; dq = new LinkedList&lt;&gt;(); map = new HashSet&lt;&gt;(); size = n; &#125; public void refer(int x)&#123; if(!map.contains(x))&#123; if(dq.size() == size)&#123; int last = dq.removeLast(); map.remove(x); &#125; &#125; else&#123; int index = 0, i = 0; Iterator&lt;Integer&gt; itr = dq.iterator(); while(itr.hasNext())&#123; if(itr.next() == x)&#123; index = i; break; &#125; i++; &#125; dq.remove(index); &#125; dq.push(x); map.add(x); &#125;&#125;class LRUCache3&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private final int CACHE_SIZE; /** * 传递进来最多能缓存多少数据 * * @param cacheSize 缓存大小 */ public LRUCache3(int cacheSize) &#123; // true 表示让 linkedHashMap 按照访问顺序来进行排序，最近访问的放在尾部，最老访问的放在头部。 super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true); CACHE_SIZE = cacheSize; &#125; @Override protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; // 当 map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据。 return size() &gt; CACHE_SIZE; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[--------->二叉树中和为某值的路径]]></title>
    <url>%2F2019%2F09%2F09%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[———&gt;二叉树中和为某值的路径]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的后续遍历序列]]></title>
    <url>%2F2019%2F09%2F08%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[二叉搜索树的后续遍历序列123456789101112131415161718192021222324252627282930313233// 输入一个整数数组，判断该数组是否是一个二叉搜索树的后序遍历结果// 如果是则返回true, 否则返回falsepublic class A26_VerifySquenceOfBST &#123; public static boolean verifySquenceOfBST(int[] sequence)&#123; int n = sequence.length; if(sequence == null || n &lt;= 0)&#123; return false; &#125; return judge(sequence, 0, sequence.length-1); &#125; public static boolean judge(int[] arr, int start, int end)&#123; if(start &gt;= end)&#123; // 递归终止条件 return true; &#125; // 找到右子树序列 int i = end; while (i &gt; start &amp;&amp; arr[i - 1] &gt; arr[end])&#123; i--; &#125; // 检查左子树序列元素 是否 都小于 根元素 for(int j = start; j &lt;= i-1; j++)&#123; if(arr[j] &gt; arr[end])&#123; return false; &#125; &#125; return judge(arr, start, i-1) &amp;&amp; judge(arr, i, end-1); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-------之字型打印二叉树]]></title>
    <url>%2F2019%2F09%2F05%2F%E4%B9%8B%E5%AD%97%E5%9E%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[——–之字型打印二叉树]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从上到下打印二叉树]]></title>
    <url>%2F2019%2F09%2F05%2F%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[从上到下打印二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 从上到下打印二叉树public class A25_PrintFromTopToBottom &#123; // 遍历 public static ArrayList&lt;Integer&gt; order(TreeNode root)&#123; if(root == null)&#123; return null; &#125; Deque&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode tmp = queue.poll(); list.add(tmp.value); if(tmp.left != null)&#123; queue.offer(tmp.left); &#125; if(tmp.right != null)&#123; queue.offer(tmp.right); &#125; &#125; return list; &#125; // 递归 public static ArrayList&lt;Integer&gt; order2(TreeNode root)&#123; if(root == null)&#123; return null; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(root.value); list(root, list); return list; &#125; public static void list(TreeNode root, ArrayList&lt;Integer&gt; list)&#123; if(root == null)&#123; return ; &#125; if(root.left != null)&#123; list.add(root.left.value); &#125; if(root.right != null)&#123; list.add(root.right.value); &#125; list(root.left, list); list(root.right, list); &#125; // 按行号上到下打印 public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; order3(TreeNode root)&#123; if(root == null)&#123; return null; &#125; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); queue.add(root); int start = 0; int end = 1; while(!queue.isEmpty())&#123; TreeNode tmp = queue.poll(); arr.add(tmp.value); start++; if(tmp.left != null)&#123; queue.offer(tmp.left); &#125; if(tmp.right != null)&#123; queue.offer(tmp.right); &#125; if(start == end)&#123; start = 0; end = queue.size(); list.add(new ArrayList&lt;Integer&gt;(arr)); arr.clear(); &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断一个栈是否是另一个栈的弹出序列]]></title>
    <url>%2F2019%2F09%2F03%2F%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%A0%88%E6%98%AF%E5%90%A6%E6%98%AF%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%88%E7%9A%84%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[判断一个栈是否是另一个栈的弹出序列12345678910111213141516171819// 输入两个整数序列，第一个序列表示压入顺序，判断第二个序列是否为弹出顺序public class A24_IsPopOrder &#123; public static boolean isPopOrder(int[] pushList, int[] popList)&#123; if(pushList == null || popList == null)&#123; return false; &#125; int point = 0; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for(int i = 0; i &lt; pushList.length; i++)&#123; stack.push(pushList[i]); while(!stack.isEmpty() &amp;&amp; stack.peek() == popList[point])&#123; stack.pop(); point++; &#125; &#125; return stack.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包含min函数的栈]]></title>
    <url>%2F2019%2F09%2F03%2F%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[包含min函数的栈1234567891011121314151617181920212223// 包含min函数的栈public class A23_StackWithMin &#123; private static Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); private static Stack&lt;Integer&gt; stackMin = new Stack&lt;Integer&gt;(); public static void push(Integer n)&#123; if(stackMin.isEmpty() || stackMin.peek() &gt; n)&#123; stackMin.push(n); &#125; else&#123; stackMin.push(stackMin.peek()); &#125; stack.push(n); &#125; public static void pop()&#123; stack.pop(); stackMin.pop(); &#125; public static Integer min()&#123; return stackMin.empty() ? -1 : stackMin.peek(); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树是否对称]]></title>
    <url>%2F2019%2F09%2F02%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%AF%B9%E7%A7%B0%2F</url>
    <content type="text"><![CDATA[二叉树是否对称123456789101112131415161718192021// 判断树是否对称public class A22_IsSymmetrical &#123; // 判断左右子树是否相等 public static boolean isSymmetrical(TreeNode root)&#123; return root == null || isCommon(root.left, root.right); &#125; public static boolean isCommon(TreeNode left, TreeNode right)&#123; if(left == null &amp;&amp; right == null)&#123; return true; &#125; if(left == null || right == null)&#123; return false; &#125; return left.value == right.value &amp;&amp; isCommon(left.left, right.right) &amp;&amp; isCommon(left.right, right.left); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的镜像]]></title>
    <url>%2F2019%2F09%2F02%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[二叉树的镜像12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Stack;// 输入一个二叉树，输出它的的镜像public class A21_TreeMirror &#123; // 递归 public static void mirror(TreeNode root)&#123; if(root == null)&#123; return ; &#125; TreeNode tmp = root.left; root.left = root.right; root.right = tmp; mirror(root.left); mirror(root.right); &#125; // 非递归 栈 public static void mirror2(TreeNode root)&#123; if (root == null) &#123; return ; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; // 交换左右子节点 TreeNode temp = root.left; root.left = root.right; root.right = temp; stack.push(root); root = root.left; &#125; root = stack.pop(); root = root.right; &#125; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树A是否含有树B]]></title>
    <url>%2F2019%2F08%2F30%2F%E6%A0%91A%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E6%A0%91B%2F</url>
    <content type="text"><![CDATA[树A是否含有树B123456789101112131415161718192021222324252627282930313233public class A20_HasSubTree &#123; public static boolean hasSubTree(TreeNode source, TreeNode target)&#123; if(target == null)&#123; return true; &#125; if(source == null)&#123; return false; &#125; if(tree1HasTree2(source, target))&#123; return true; &#125; return hasSubTree(source.left, target) || hasSubTree(source.right, target); &#125; public static boolean tree1HasTree2(TreeNode source, TreeNode target)&#123; if(target == null &amp;&amp; source == null)&#123; return true; &#125; if(target == null || source == null)&#123; return false; &#125; if(target.value != source.value)&#123; return false; &#125; return tree1HasTree2(source.left, target.left) &amp;&amp; tree1HasTree2(source.right, target.right); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合并两个有序链表]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[合并两个有序链表1234567891011121314151617181920public class A19_mergeTwoList &#123; public static Node merge(Node n1, Node n2)&#123; Node preHead = new Node(-1,null); Node curr = preHead; while(n1 != null &amp;&amp; n2 != null)&#123; if(n1.getValue() &lt; n2.getValue())&#123; curr.setNext(n1); n1 = n1.getNext(); &#125; else&#123; curr.setNext(n2); n2 = n2.getNext(); &#125; curr = curr.getNext(); &#125; curr.setNext(n1 == null ? n2 : n1); return preHead.getNext(); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反转链表]]></title>
    <url>%2F2019%2F08%2F29%2F%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转链表1234567891011121314151617181920212223242526272829303132333435public class A17_reverseList &#123; public static Node reverseList(Node head)&#123; Node pre = null; Node curr = head; while(curr != null)&#123; Node tmp = curr.getNext(); curr.setNext(pre); pre = curr; curr = tmp; &#125; return pre; &#125; public static Node rever(Node head)&#123; Node pre = null; while(head != null)&#123; Node tmp = head.getNext(); head.setNext(pre); pre = head; head = tmp; &#125; return pre; &#125; public static void main(String[] args)&#123; Node n1 = new Node(1,null); Node n2 = new Node(2,n1); Node n3 = new Node(3,n2); Node n4 = new Node(4,n3); Node.print(n4); System.out.println(); Node.print(reverseList(n4)); &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环链表的入口节点]]></title>
    <url>%2F2019%2F08%2F28%2F%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[环链表的入口节点解法快指针走两步，慢指针走一步。相遇的时候，慢指针走了 k 步，环之外的长度为 x ，环的长度为 n ，则快指针走了 x+m*n (m为圈数) ,慢指针走了 x+k 步。解得 慢指针在圈中还有 n-k 步未走。假设当 m=1 时，x=n-k。所以，快指针从头在走时，与慢指针在相遇时，即为入口节点 12345678910111213141516171819202122232425public static Node enterNodeOfLoop(Node head)&#123; if(head == null || head .next == null)&#123; return null; &#125; Node slow = head; Node fast = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if(fast == slow)&#123; fast = head; while(fast != slow)&#123; fast = fast.next; slow = slow.next; &#125; return slow; &#125; &#125; return null; &#125; class Node&#123; int val; Node next; &#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表中倒数第K个节点]]></title>
    <url>%2F2019%2F08%2F27%2F%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[链表中倒数第K个节点输入一个链表，输出该链表中倒数第K个节点 解法为了实现遍历链表一次就能找到第k个节点，快慢指针法。 123456789101112131415161718192021222324252627282930313233343536373839404142// 输入一个链表，输出该链表的第k个节点public class A15_FindKthToTail &#123; // 快慢指针法，快指针先走k步，然后两指针同时走 public static Node findKthToTail(Node head, int k)&#123; if(head == null || k &lt; 1)&#123; return null; &#125; Node fast = head; Node slow = head; while(k-- &gt; 1)&#123; if(fast.getNext() == null)&#123; return null; &#125; fast = fast.getNext(); &#125; while(fast.getNext() != null)&#123; fast = fast.getNext(); slow = slow.getNext(); &#125; return slow; &#125; // 不推荐 O(n^2) public static Node findKthToTail2(Node head, int k) &#123; int length = 0; Node p = head; while (p != null) &#123; length++; p = p.getNext(); &#125; Node target = null; if (length == k) &#123; target = head; &#125; for (int i = 0; i &lt; length - k; i++) &#123; head = head.getNext(); target = head; &#125; return target; &#125;&#125;]]></content>
      <categories>
        <category>sword offer</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java I/O模型从BIO到NIO和Reactor模式解析]]></title>
    <url>%2F2019%2F08%2F25%2FJava-I-O%E6%A8%A1%E5%9E%8B%E4%BB%8EBIO%E5%88%B0NIO%E5%92%8CReactor%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Java I/O模型从BIO到NIO和Reactor模式解析]]></content>
      <categories>
        <category>java</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机性能监控工具]]></title>
    <url>%2F2019%2F08%2F25%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Java虚拟机性能监控工具 一、JDK的命令行工具 二、JDK的可视化工具 三、性能调优 一、JDK的命令行工具主要有以下几种: jps (Java Process Status Tool): 虚拟机进程状态工具； jstat (JVM Statistics Monitoring Tool): 虚拟机统计信息监视工具； jinfo (Configuration Info for Java): Java配置信息工具； jmap (Memory Map for Java): Java内存映像工具； jhat (JVM Heap Dump Browser): 虚拟机堆转存储快照工具； jstack (Stack Trace for Java): Java堆栈跟踪工具； 下面一个个来总结: 1、jps : 虚拟机进程状态工具 jps（JVM Process Status Tool，虚拟机进程监控工具），这个命令可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称，以及这些进程的本地虚拟机唯一ID。 这个 ID 被称为本地虚拟机唯一 ID（Local Virtual Machine Identifier，简写为LVMID）。如果你在 linux 的一台服务器上使用 jps 得到的 LVMID 其实就是和 ps 命令得到的 PID 是一样的。 命令格式: 1jps [options] [hostid] jps工具主要选项： -q，只输出LVMID，省略主类的名称； -m，输出虚拟机进程启动时传给主类main()函数的参数； -l，输出主类的全名，如果进程执行的是Jar包，输出Jar路径； -v，输出虚拟机进程启动时JVM参数； 2、jstat : 虚拟机统计信息监视工具 jstat（JVM Statistics Monitoring Tool，虚拟机统计信息监视工具），这个命令用于监视虚拟机各种运行状态信息。 它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，虽然没有GUI图形界面，只是提供了纯文本控制台环境的服务器上，但它是运行期间定位虚拟机性能问题的首选工具。 命令格式: 1jstat [option vmid [interval [s | ms] [count ] ] ] option代表着用户希望查询的虚拟机信息，主要分为3类: 类装载、垃圾收集、运行期编译状况，具体可以参照下表: 更多jstat的详细讲解可以参考这篇博客。 3、jinfo ：Java配置信息工具 实时地查看和调整虚拟机各项参数。 查看14838是否使用CMS收集器: 1jinfo -flag UseConcMarkSweepGC 14836 查看2788的MaxPerm大小可以用 1jinfo -flag MaxPermSize 2788 4、jmap : Java内存映像工具 jmap（Memory Map for Java，内存映像工具），用于生成堆转存的快照，一般是 heapdump 或者 dump 文件。如果不使用 jmap 命令，可以使用 -XX:+HeapDumpOnOutOfMemoryError 参数，当虚拟机发生内存溢出的时候可以产生快照。或者使用kill -3 pid也可以产生。 jmap 的作用并不仅仅是为了获取 dump 文件，它可以查询 finalize 执行队列，java 堆和永久代的详细信息，如空间使用率，当前用的哪种收集器。 格式: 1jmap [option] vmid 5、jhat : 虚拟机堆转存储快照工具 jhat（虚拟机堆转储快照分析工具），这个工具是用来分析 jmap dump 出来的文件。 由于这个工具功能比较简陋，运行起来也比较耗时，所以这个工具不推荐使用，推荐使用MAT。 分析示例: 6、jstack ： Java堆栈跟踪工具 jstack（Java Stack Trace，Java堆栈跟踪工具），这个命令用于查看虚拟机当前时刻的线程快照（一般是threaddump 或者 javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。 生成线程快照的主要目的是：定位线程出现长时间停顿的原因，入线程间死锁、死循环、请求外部资源导致的长时间等待都是导致线程长时间停顿的常见原因。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情。 命令格式： 1jstack [option] vmid 使用：查看进程8024 的堆栈信息 1jstack 8024 二、 JDK的可视化工具 Jconsole : Java监视与管理控制台 VisualVM: 多合一故障处理工具 下面具体看这个两个工具: 1、 Jconsole : Java监视与管理控制台 JConsole可以监视JVM 内存的使用情况、线程堆栈跟踪、已装入的类和 VM 信息以及 CE MBean。 JConsole一个 Java GUI 监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。 用 Java 写的 GUI 程序，用来监控 VM，并可监控远程的 VM，非常易用，而且功能非常强。命令行里打 Jconsole，选则进程就可以了。 可以监控内存和线程，以及检测是否出现死锁； 2、VisualVM ：多合一故障处理工具 VisualVm 同 Jconsole 都是一个基于图形化界面的、可以查看本地及远程的 JAVA GUI 监控工具，VisualVm 同 Jconsole 的使用方式一样，直接在命令行打入JVisualVm 即可启动，VisualVm 界面更美观一些，数据更实时。 性能调优性能调优: 知识 工具 数据 经验 关于性能调优更多的可以看看这篇JVM性能调优案例。]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2F2019%2F08%2F24%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[垃圾收集器与内存分配策略确定对象存活1.1 引用计数算法 给对象添加一个引用计数器，每当有对象引用它时；计数器+1；引用失效时，计数器 -1；任何时刻计数器为0的对象就是不可能再被使用的。 很难解决对象之间互相循环引用问题 1.2 可达性分析算法 基本思路就是通过一系列称为‘GC Roots’的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链Reference Chain，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。可作为GC Roots对象： 虚拟机栈（栈帧中的本地变量表）中的引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI(native 方法）引用的对象。 引用类型 无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否可被回收都与引用有关。 1.强引用 被强引用关联的对象不会被垃圾收集器回收。 使用 new 一个新对象的方式来创建强引 1Object obj = new Object(); 2.软引用 被软引用关联的对象，只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 3.弱引用 被弱引用关联的对象一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。 使用 WeakReference 类来实现弱引用。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; WeakHashMap 的 Entry 继承自 WeakReference，主要用来实现缓存。 private static class Entry&lt;K,V&gt; extends WeakReference implements Map.Entry&lt;K,V&gt; Tomcat 中的 ConcurrentCache 就使用了 WeakHashMap 来实现缓存功能。ConcurrentCache 采取的是分代缓存，经常使用的对象放入 eden 中，而不常用的对象放入 longterm。eden 使用 ConcurrentHashMap 实现，longterm 使用 WeakHashMap，保证了不常使用的对象容易被回收。 1234567891011121314151617181920212223242526272829303132public final class ConcurrentCache&lt;K, V&gt; &#123; private final int size; private final Map&lt;K, V&gt; eden; private final Map&lt;K, V&gt; longterm; public ConcurrentCache(int size) &#123; this.size = size; this.eden = new ConcurrentHashMap&lt;&gt;(size); this.longterm = new WeakHashMap&lt;&gt;(size); &#125; public V get(K k) &#123; V v = this.eden.get(k); if (v == null) &#123; v = this.longterm.get(k); if (v != null) this.eden.put(k, v); &#125; return v; &#125; public void put(K k, V v) &#123; if (this.eden.size() &gt;= size) &#123; this.longterm.putAll(this.eden); this.eden.clear(); &#125; this.eden.put(k, v); &#125;&#125; 4.虚引用 又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj);obj = null; finalize()方法 方法区回收 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代差很多，因此在方法区上进行回收性价比不高。 主要是对常量池的回收（废弃常量）和对类的卸载（无用的类） 类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法 可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。 垃圾收集算法 标记-清除：将需要回收的对象进行标记，然后清理掉被标记的对象。不足： 标记和清除过程效率都不高 会产生大量不连续的内存碎片，导致无法给大对象分配内 复制算法 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要缺点：只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90 %。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。 3.标记-整理算法 复制算法在对象存活率较高时要进行较多的复制操作，效率会变低。更关键的是如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存货的极端情况。 标记过程仍然和’标记-清除‘算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 4.分代收集算法 当前商用虚拟机主要都采用该算法。 根据对象存活周期的不同将内存划分为多块。一般将Java堆分为新生代、老年代。 新生代，每次垃圾收集都发现有大批对象死去，少量存活，选用’复制算法’ 老年代存活率较高，选用’标记-清除‘或者’标记-整理‘算法。 垃圾收集器 1.Serial 收集器 Serial 翻译为串行，可以理解为垃圾收集和用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序。除了 CMS 和 G1 之外，其它收集器都是以串行的方式执行。CMS 和 G1 可以使得垃圾收集和用户程序同时执行，被称为并发执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率 它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。 2.ParNew 收集器 它是 Serial 收集器的多线程版本。 是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 3.Parallel Scavenge 收集器 与 ParNew 一样是并行的多线程收集器。 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间(运行用户代码时间+GC时间)的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。 4.Serial Old 收集器 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。如果用在 Server 模式下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 5.Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 6.CMS 收集器 CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 特点：并发收集、低停顿。并发指的是用户线程和 GC 线程同时运行。以下四流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。可以使用 -XX:CMSInitiatingOccupancyFraction 来改变触发 CMS 收集器工作的内存占用百分，如果这个值设置的太大，导致预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 7.G1 收集器 G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 Java 堆被分为新生代、老年代和永久代，其它收集器进行收集的范围都是整个新生代或者老生代，而 G1 可以直接对新生代和永久代一起回收。 G1 把新生代和老年代划分成多个大小相等的独立区域（Region），新生代和永久代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 记录垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 特点 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 比较 收集器 串行/并行/并发 新生代/老年代 收集算法 目标 适用场景 Serial 串行 新生代 复制 响应速度优先 单 CPU 环境下的 Client 模式 Serial Old 串行 老年代 标记-整理 响应速度优先 单 CPU 环境下的 Client 模式、CMS 的后备预案 ParNew 串行 + 并行 新生代 复制算法 响应速度优先 多 CPU 环境时在 Server 模式下与 CMS 配合 Parallel Scavenge 串行 + 并行 新生代 复制算法 吞吐量优先 在后台运算而不需要太多交互的任务 Parallel Old 串行 + 并行 老年代 标记-整理 吞吐量优先 在后台运算而不需要太多交互的任务 CMS 并行 + 并发 老年代 标记-清除 响应速度优先 集中在互联网站或 B/S 系统服务端上的 Java 应用 G1 并行 + 并发 新生代 + 老年代 标记-整理 + 复制算法 响应速度优先 面向服务端应用，将来替换 CMS 内存分配与回收策略对象的内存分配，也就是在堆上分配。主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中。 Minor GC 和 Full GC Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：发生在老年代上，老年代对象和新生代的相反，其存活时间长，因此 Full GC 很少执行，而且执行速度会比 Minor GC 慢很多。 内存分配策略 对象优先在 Eden 分配,大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。 大对象直接进入老年代,大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。 长期存活的对象进入老年代,为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 动态对象年龄判定,虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保,在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那这时也要改为进行一次 Full GC。 Full GC 的触发条件对于 Minor GC，其触发条件非常简单，当 Eden 区空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： 调用 System.gc():此方法的调用是建议虚拟机进行 Full GC，虽然只是建议而非一定，但很多情况下它会触发 Full GC，从而增加 Full GC 的频率，也即增加了间歇性停顿的次数。因此强烈建议能不使用此方法就不要使用，让虚拟机自己去管理它的内存。可通过 -XX:DisableExplicitGC 来禁止 RMI 调用 System.gc()。 老年代空间不足:老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等，当执行 Full GC 后空间仍然不足，则抛出 Java.lang.OutOfMemoryError。为避免以上原因引起的 Full GC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间以及不要创建过大的对象及数组。 空间分配担保失败:使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果出现了 HandlePromotionFailure 担保失败，则会触发 Full GC。 JDK 1.7 及以前的永久代空间不足:在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError，为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 Concurrent Mode Failure:执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC），便会报 Concurrent Mode Failure 错误，并触发 Full GC。]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存区域与内存溢出异常]]></title>
    <url>%2F2019%2F08%2F24%2FJVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[JVM内存区域与内存溢出异常运行区数据区域 Java 虚拟机执行java程序过程中，会将内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。1.1 程序计数器 线程所执行的字节码的行号指示器 各线程之间的计数器互不影响、独立存储、线程私有的内存 1.2 Java虚拟机栈 线程私有 存储局部变量表、操作数栈、动态链接、方法出口等信息 局部变量表存放了编译期可知的各种基本数据类型：boolean、byte、char、short、int、float、long、double；对象引用 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，则抛出OutOfMemoryError异常 1.3 本地方法栈 与虚拟机栈发挥的作用相似，区别是虚拟机栈为虚拟机执行java方法（也就是字节码）服务，本地方法栈则为虚拟机使用到得Native方法服务 也会抛出StackOverflowError、OutOfMemoryError异常 2.1 Java堆 被所有线程共享的一块内存区域，在虚拟机启动时创建，唯一目的就是存放对象实例，几乎所有对象实例都在这里分配内存。 垃圾收集器管理的主要区域，”GC堆“ Garbage Collected Heap 由于收集器基本采用分代手机算法，可细分：新生代、老生代，再细致：Eden空间、From Survivor 空间、To Survivor空间 会抛出OutOfMemoryError 是垃圾收集的主要区域（”GC 堆”），现代的垃圾收集器基本都是采用分代收集算法，该算法的思想是针对不同的对象采取不同的垃圾回收算法，因此虚拟机把 Java 堆分成以下三块： 新生代（Young Generation） 老年代（Old Generation） 永久代（Permanent Generation）：涉及到内存模型时，往往会提到永久代，那么它和方法区又是什么关系呢？《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 同时，大多数用的JVM都是Sun公司的HotSpot。在HotSpot上把GC分代收集扩展至方法区，或者说使用永久代来实现方法区。 当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效地进行垃圾回收，把新生代继续划分成以下三个空间： Eden From Survivor To Survivor 2.2.1 方法区 线程共享的内存区域 存储已被虚拟机加载的类信息（类名、访问修饰符、字段描述、方法描述）、常量（池）、静态变量、即时编译后的代码 会抛出OutOfMemoryError异常 2.2.2 运行时常量池 方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放 2.2.3 直接内存 并不是虚拟机运行时的数据区的一部分、也不是java虚拟机规范中定义的内存区域 JDK1.4引入NIO，假如一种基于通道Channel与缓冲区buffer的I/O方式 它可以使用Native函数库直接分配对外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据 HotSpot虚拟机对象探秘1.1 对象的创建 普通对象：不包括数组、Class对象 虚拟机遇到new指令，首先检查这个指令的参数是否在常量池中定位到一个类的符号引用，并且检察这个符号引用代表的类是否被加载、解析、初始化过。如果没有，须执行相应的类加载过程 类检查通过之后，可确定内存，为对象分配内存。 分配方式(取决于Java堆是否规整) 指针碰撞 Bump the Pointer：假设java堆中内存绝对规整，已用内存放一侧，未用内存放一侧，中间放着一个指针为分界点的指示器，那所分配的内存就仅仅将那个指针向空闲区域挪动一段与对象大小相等的距离 空闲列表 Free List：记录哪些内存可用、不可用，并更新列表记录 对象在内存中是否频繁创建，并发情况下并不是线程安全的，可能在给对象A分配内存，指针还没及时修改，对象B又同时使用了原来的指针分配内存的情况，方案： 分配内存进行同步处理，实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。 把内存分配的动作按照线程划分在不同的空间之中进行。即每个线程在Java堆中预先分配一小块内存（本地线程分配缓冲 Thread Local Allocation Buffer TLAB）。哪个线程要分配内存，就在对应TLAB中分配，TLAB用完时，在同步锁定，并分配新的TLAB。虚拟机是否使用TLAB 通过 -XX:+/-UseTLAB 参数来设定 内存分配完后，将空间都初始化为数据类型对应的零值（不包括对象头），如果使用TLAB方式，这一过程可提前至TLAB分配时进行。这一操作保证了对象的实例字段在Java代码中可以不赋初始化值就直接使用。 对象中所有字段都是零，接下来执行-init-方法，创建具体对象 1.2 对象的内存格局 对象头 Header 内容 1 ：存储对象自身的运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳 内容 2 ：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象属于哪个类的实例。并不是所有的虚拟机都必须实现在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是数组，对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java数组对象的元数据信息确定java对象的大小，但从数组的元数据中却无法确定数组的大小 实例数据 Instance Data ： 程序代码中所定义的各种类型的字段内容。 对齐填充 Padding ：并不是必然存在的，没特别含义，仅仅起着占位符的作用。HotSpot VM 的自动内存管理系统要求对象的起始地址是8字节的整数倍，即对象的大小必须是8字节的整数倍。假如不是，需通过对齐填充来补全 1.3 对象的访问定位 句柄方式：Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。而句柄中包含了对象实例数据与类型数据各自的具体地址信息 直接地址访问：reference中存储对象的地址。 各有优势，句柄访问最大的好处就是reference中存储的是稳定的句柄地址，在对象移动（垃圾手收集时移动对象时非常普遍的行为）时只会改变句柄中实例数据指针。直接指针访问，节省了一次指针定位的时间开销。由于对象的访问在java中非常频繁，这类开销积少成多后也是一项非常可观的执行成本。 实战OutOfMemoryError异常在java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError异常的可能。 Java堆溢出 用于存储对象实例，只要不断创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后，就会产生内存溢出 将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免自动扩展堆内存，参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析 内存映像分析工具，如Eclipse Memory Analuzer 虚拟机栈和本地方法栈溢出 如果线程请求的栈深度大于虚拟机所允许的最大深度，抛出StackOverflowError异常 如果虚拟机在扩展栈时无法申请到足够内存空间，抛出OutOfMemoryError异常 单个线程下，无论是栈帧太大还是虚拟机容量太小，当内存无法分配的时候，都抛出StackOverflowError异常 多线程下，系统除去堆、方法区内存，程序计数器消耗可忽略，剩余栈使用，被多线程瓜分，如果使用默认虚拟机参数，栈深度够用，当出现Stack OverflowError异常时，在不减少线程数或者更换64位虚拟机情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程数。 方法区和运行时常量池溢出 String.intern() native方法，如果字符串常量池中已经包含一个等于此String对象的字符串，则返回常量池中的String对象引用；否则将此对象包含的字符串添加到常量池中，并且返回此String对象的引用。 类 -XX:PermSize 和 -XX:MaxPermSize 限制方法区大小 OutOfMemoryError PermGen space 本机直接内存溢出 DirectMemory容量通过 -XX:MaxDirectMemorySize指定，如不指定，则默认与Java堆对大致（-Xmx指定）一样 JVM调优https://tech.meituan.com/2017/12/29/jvm-optimize.htmlhttps://github.com/dunwu/JavaCore/blob/master/docs/jvm/4-JVM调优.md 虚拟机性能监控工具https://github.com/ZXZxin/ZXBlog/blob/master/Java基础/JVM/Java虚拟机性能监控工具.md]]></content>
      <categories>
        <category>java</category>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
</search>
